/**
 * Copyright 2022 Micro Focus or one of its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Text;
using System.Text.Json.Nodes;
using YamlDotNet.Serialization;

namespace MicroFocus.FAS.AdapterSdkSchema
{
    public class SchemaSourceCreator
    {
        private static readonly string NAMESPACE_NAME = "MicroFocus.FAS.AdapterSdkSchema";
        private static readonly string CLASS_NAME = "AdapterSdkSchema";
        private static readonly HashSet<string> PROPERTY_TYPES = new() {
            "STRING", "FULLTEXT", "LONG", "DOUBLE", "INTEGER", "BOOLEAN", "DATETIME",
            "STRING[]", "FULLTEXT[]", "LONG[]", "DOUBLE[]", "INTEGER[]", "BOOLEAN[]", "DATETIME[]"};

        private readonly List<PropertyNameHelper> propertyNames;
        private JsonNode typesNode;
        private readonly StringBuilder typesDefinitionBuilder;

        private SchemaSourceCreator()
        {
            propertyNames = new List<PropertyNameHelper>();
            typesDefinitionBuilder = new();
        }

        public static string Create()
        {
            // parse the schema file
            JsonNode schemaJson = ParseSchema();

            // Define a class
            var schemaSource = new SchemaSourceCreator().CreateSchemaSource(schemaJson);
            Debug.WriteLine("schema source : " + schemaSource);
            return schemaSource;
        }

        private static JsonNode ParseSchema()
        {
            string schemaFile = Path.Combine(
                Directory.GetParent(System.IO.Directory.GetCurrentDirectory())
                .Parent.Parent.Parent.Parent.Parent.FullName,
                "schemaDefinition.json.yaml");
            //Debug.WriteLine("schemaFile path : " + schemaFile);
            // TODO: Remove hardcoded path
            schemaFile = @"C:\Projects\AspenGit\cSharp\adaptersdk-schema\schemaDefinition.json.yaml";
            var schemaReader = new StreamReader(schemaFile);
            var schemaDeserializer = new Deserializer();
            var yamlSchema = schemaDeserializer.Deserialize(schemaReader);

            var serializer = new SerializerBuilder().JsonCompatible().Build();
            var json = serializer.Serialize(yamlSchema);

            return JsonNode.Parse(json);
        }

        private string CreateSchemaSource(JsonNode schemaJson)
        {
            typesNode = schemaJson["types"].AsObject();
            JsonNode fields = schemaJson["fields"].AsObject();

            //Debug.WriteLine("schema fields : " + fields);

            StringBuilder sourceBuilder = new("// This file is auto-generated by SchemaGenerator\nusing System;");
            sourceBuilder
                .Append("namespace ")
                .Append(NAMESPACE_NAME)
                .Append("{public static class ")
                .Append(CLASS_NAME)
                .Append("{");

            // Add properties
            AddPropertyFields(sourceBuilder, fields, new string[0], "", true);

            // Add property accessors
            AddPropertyAccessors(sourceBuilder);

            // Add types definitions
            sourceBuilder.Append(typesDefinitionBuilder);

            // End the class
            sourceBuilder.Append("}}"); // end namespace
            return sourceBuilder.ToString();
        }

        private void AddPropertyFields(StringBuilder sourceBuilder, JsonNode entityDef, string[] path, string parentFieldName, bool initialize)
        {
            IEnumerator<KeyValuePair<string, JsonNode>> propertyIterator = entityDef.AsObject().GetEnumerator();

            bool isSubfield = path.Length > 0;
            string fieldImplClass = isSubfield ? "SubfieldImpl" : "FieldImpl";
            string fieldOrTypeModifiers = isSubfield ? "public readonly" : "public static readonly";

            while (propertyIterator.MoveNext())
            {
                KeyValuePair<string, JsonNode> property = propertyIterator.Current;
                JsonNode fieldAttributes = property.Value;
                string propertyName = property.Key;
                string ucPropertyName = propertyName.ToUpper();
                string sanitizedPropertyName = ucPropertyName.Replace('-', '_');

                if (!isSubfield)
                {
                    propertyNames.Add(new PropertyNameHelper(propertyName, ucPropertyName, sanitizedPropertyName));
                }
                else
                {
                    string subFieldPropertyName = parentFieldName + "." + propertyName;
                    string subFieldUcPropertyName = subFieldPropertyName.ToUpper();
                    string subFieldSanitizedPropertyName = subFieldUcPropertyName.Replace('-', '_');

                    propertyNames.Add(new PropertyNameHelper(subFieldPropertyName, subFieldUcPropertyName, subFieldSanitizedPropertyName));
                }

                string fieldType = fieldAttributes["type"].GetValue<string>();

                string fldEncoding =
                    fieldAttributes["objectEncoding"] != null
                    ? fieldAttributes["objectEncoding"].GetValue<string>()
                    : "json";
                bool fldIsMultiValued = fieldType.EndsWith("[]");
                bool fldIsMandatory =
                    fieldAttributes["mandatory"] != null
                    && Boolean.Parse(fieldAttributes["mandatory"].GetValue<string>());
                bool fldIsCaseInsensitive =
                    fieldAttributes["ignoreCase"] != null
                    && Boolean.Parse(fieldAttributes["ignoreCase"].GetValue<string>());
                bool fldIsTokenizedPath =
                    fieldAttributes["tokenizedPath"] != null
                    && Boolean.Parse(fieldAttributes["tokenizedPath"].GetValue<string>());

                if (!PROPERTY_TYPES.Contains(fieldType))
                {
                    string fieldName = ToProperCase(propertyName) + "Field";
                    string[] newPath = AddExtraElement(path, fieldName);
                    string fullName = isSubfield ? parentFieldName + "." + propertyName : propertyName;

                    string fieldClassName = String.Join(".", newPath);

                    string field = fieldOrTypeModifiers + " " + fieldClassName + " " + sanitizedPropertyName
                                   + " = new " + fieldClassName + "();";
                    sourceBuilder.Append(field);

                    int endOfTypeName = fieldType.IndexOf('[');
                    string refTypeName = endOfTypeName > 0 ? fieldType.Substring(0, endOfTypeName) : fieldType;
                    JsonNode subentityDef = typesNode[refTypeName];

                    StringBuilder fieldClassBuiler = new();
                    fieldClassBuiler.Append("public class ").Append(fieldName).Append(" : ").Append(isSubfield ? "IStructuredSubfield" : "IStructuredField");
                    fieldClassBuiler.Append("{ private readonly IField field;");
                    StringBuilder subFieldsBuilder = new();
                    AddPropertyFields(subFieldsBuilder, subentityDef, newPath, fullName, false);
                    fieldClassBuiler.Append(subFieldsBuilder.ToString());

                    subFieldsBuilder.Clear();

                    // Implement IField interface
                    subFieldsBuilder
                        .Append("public string FieldName => field.FieldName;")
                        .Append("public string FieldType => field.FieldType;")
                        .Append("public ObjectEncodingOption ObjectEncoding => field.ObjectEncoding;")
                        .Append("public IField ParentField => field.ParentField;")
                        .Append("public bool IsMultivalue => field.IsMultivalue;")
                        .Append("public bool IsMandatory => field.IsMandatory;")
                        .Append("public bool IsCaseInsensitive => field.IsCaseInsensitive;")
                        .Append("public bool IsTokenizedPath => field.IsTokenizedPath;");
                    fieldClassBuiler.Append(subFieldsBuilder);

                    // Define constructor
                    fieldClassBuiler.Append("public ").Append(fieldClassName).Append("()");
                    fieldClassBuiler.Append("{");
                    fieldClassBuiler.Append("field = new FieldImpl(");
                    fieldClassBuiler.Append("\"").Append(propertyName).Append("\", ");
                    fieldClassBuiler.Append("\"").Append(fieldType).Append("\", ");
                    fieldClassBuiler.Append(fldEncoding.Equals("json") ? "ObjectEncodingOption.Json" : "ObjectEncodingOption.Flattened").Append(", ");
                    fieldClassBuiler.Append(fldIsMultiValued.ToString().ToLower()).Append(", ");
                    fieldClassBuiler.Append(fldIsMandatory.ToString().ToLower()).Append(", ");
                    fieldClassBuiler.Append(fldIsCaseInsensitive.ToString().ToLower()).Append(", ");
                    fieldClassBuiler.Append(fldIsTokenizedPath.ToString().ToLower()).Append(");");
                    // + (isSubfield ? ", " + path[path.Length - 1] + ".this)" : ")");

                    subFieldsBuilder.Clear();
                    //InitializeSubPropertyFields(subFieldsBuilder, subentityDef, newPath, fullName);

                    fieldClassBuiler.Append("}}");

                    typesDefinitionBuilder.Append(fieldClassBuiler);
                }
                else
                {
                    string field = fieldOrTypeModifiers
                        + (isSubfield ? " ISubfield " : " IField ")
                        + sanitizedPropertyName
                        + (initialize
                           ? "= new " + fieldImplClass + "("
                                + "\"" + propertyName + "\", "
                                + "\"" + fieldType + "\", "
                                + (fldEncoding.Equals("json") ? "ObjectEncodingOption.Json" : "ObjectEncodingOption.Flattened") + ", "
                                + fldIsMultiValued.ToString().ToLower() + ", "
                                + fldIsMandatory.ToString().ToLower() + ", "
                                + fldIsCaseInsensitive.ToString().ToLower() + ", "
                                + fldIsTokenizedPath.ToString().ToLower()
                                + (isSubfield ? ", this);" : ");")
                           : ";"
                           );

                    sourceBuilder.Append(field);
                }
            }
        }

        private void AddPropertyAccessors(StringBuilder sourceBuilder)
        {
            sourceBuilder.Append("public static IField GetField(string fieldName){switch (fieldName){");
            foreach (PropertyNameHelper helper in propertyNames)
            {
                AddSwitchCase(sourceBuilder, helper.propertyName, helper.sanitizedPropertyName);
            }
            AddSwitchDefault(sourceBuilder);

            sourceBuilder.Append(@"
            public static IField GetField(string fieldName, bool ignoreCase)
            {
                if (!ignoreCase)
                {
                    return GetField(fieldName);
                }
                switch (fieldName.ToUpper())
                {
                ");
            foreach (PropertyNameHelper helper in propertyNames)
            {
                AddSwitchCase(sourceBuilder, helper.ucPropertyName, helper.sanitizedPropertyName);
            }
            AddSwitchDefault(sourceBuilder);
        }

        private static void AddSwitchCase(StringBuilder sourceBuilder, string caseValue, string returnValue)
        {
            sourceBuilder.Append("case \"").Append(caseValue).Append("\": return ").Append(returnValue).Append(";");
        }

        private static void AddSwitchDefault(StringBuilder sourceBuilder)
        {
            sourceBuilder.Append("default:throw new FieldNotFoundException(fieldName);}}");
        }

        private static string ToProperCase(string str)
        {
            TextInfo textInfo = new CultureInfo("en-US", false).TextInfo;
            return textInfo.ToTitleCase(str.Replace('_', ' ').Replace('-', ' ').ToLower()).Replace(" ", "");
        }

        private static string[] AddExtraElement(string[] element, string extraElement)
        {
            string[] newPath = new string[element.Length + 1];
            element.CopyTo(newPath, 0);
            newPath[element.Length] = extraElement;
            return newPath;
        }
    }
}
