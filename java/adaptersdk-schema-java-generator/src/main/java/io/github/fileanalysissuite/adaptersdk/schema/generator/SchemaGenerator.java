/*
 * Copyright 2022 Micro Focus or one of its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.fileanalysissuite.adaptersdk.schema.generator;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeSpec.Builder;

import io.github.fileanalysissuite.adaptersdk.schema.builders.JsonBuilder;
import io.github.fileanalysissuite.adaptersdk.schema.builders.SchemaObjectBuilder;
import io.github.fileanalysissuite.adaptersdk.schema.model.Field;
import io.github.fileanalysissuite.adaptersdk.schema.model.StructuredField;
import io.github.fileanalysissuite.adaptersdk.schema.model.StructuredSubfield;
import io.github.fileanalysissuite.adaptersdk.schema.model.Subfield;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.annotation.Nonnull;
import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import org.apache.commons.io.IOUtils;
import org.codehaus.plexus.util.StringUtils;

final class SchemaGenerator
{
    private static final String PACKAGE_NAME = "io.github.fileanalysissuite.adaptersdk.schema";
    private static final String CLASS_NAME = "AdapterSdkSchema";
    private static final String BUILDER_CLASS_NAME = "AdapterSdkSchemaObjectBuilder";
    private static final Set<String> PROPERTY_TYPES
        = new HashSet<>(Arrays.asList(
            "STRING", "FULLTEXT", "LONG", "DOUBLE", "INTEGER", "BOOLEAN", "DATETIME",
            "STRING[]", "FULLTEXT[]", "LONG[]", "DOUBLE[]", "INTEGER[]", "BOOLEAN[]", "DATETIME[]"));
    private static final Map<String, Class> PROPERTY_TYPES_LOOKUP = new HashMap<String, Class>() {
        {
            put("STRING", String.class);
            put("FULLTEXT", String.class);
            put("LONG", Long.class);
            put("DOUBLE", Double.class);
            put("INTEGER", Integer.class);
            put("BOOLEAN", Boolean.class);
            put("DATETIME", Instant.class);
        }
    };

    private final Filer filer;
    private final List<PropertyNameHelper> propertyNames;
    private JsonNode typesNode;

    public static boolean generate(final Filer filer)
    {
        return new SchemaGenerator(filer).process();
    }

    private SchemaGenerator(final Filer filer)
    {
        this.filer = filer;
        this.propertyNames = new ArrayList<>();
    }

    private boolean process()
    {
        final JsonNode schemaNode = parseSchemaDefinition();

        typesNode = schemaNode.get("types");

        createSchemaClass(schemaNode);
        createSchemaObjectBuilder(schemaNode);

        return false;
    }

    private void createSchemaClass(final JsonNode schemaNode)
    {
        final TypeSpec.Builder schemaClassBuilder = TypeSpec.classBuilder(CLASS_NAME)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build());

        addPropertyFields(schemaClassBuilder, schemaNode.get("fields"), new String[0], new String());
        addPropertyAccessors(schemaClassBuilder);

        final JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, schemaClassBuilder.build())
            .addFileComment("\nThis file is auto-generated by SchemaGenerator\n").build();

        try {
            javaFile.writeTo(filer);
        } catch (final IOException e) {
            throw new RuntimeException("Unable to write out generated schema file", e);
        }
    }

    private void createSchemaObjectBuilder(final JsonNode schemaNode)
    {
        final TypeSpec.Builder schemaClassBuilder = TypeSpec.classBuilder(BUILDER_CLASS_NAME)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);

        final FieldSpec field = FieldSpec
            .builder(SchemaObjectBuilder.class, "schemaObjectBuilder")
            .addModifiers(new Modifier[]{Modifier.PRIVATE, Modifier.FINAL})
            .build();

        schemaClassBuilder.addField(field);

        final MethodSpec constructor = MethodSpec
            .constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addParameter(SchemaObjectBuilder.class, "schemaObjectBuilder", Modifier.FINAL)
            .addStatement("this.schemaObjectBuilder = schemaObjectBuilder")
            .build();

        schemaClassBuilder.addMethod(constructor);

        addPropertySetters(schemaClassBuilder, null, schemaNode.get("fields"), new String[0], new String());

        final JavaFile javaFile = JavaFile.builder(PACKAGE_NAME, schemaClassBuilder.build())
            .addFileComment("\nThis file is auto-generated by SchemaGenerator\n").build();

        try {
            javaFile.writeTo(filer);
        } catch (final IOException e) {
            throw new RuntimeException("Unable to write out generated schema builder file", e);
        }
    }

    private static JsonNode parseSchemaDefinition()
    {
        try {
            return parseSchema("schemaDefinition.json.yaml");
        } catch (final IOException e) {
            throw new RuntimeException("Unable to parse schema", e);
        }
    }

    private static JsonNode parseSchema(final String schemaPath) throws IOException
    {
        final String schema;
        try (final InputStream stream = SchemaGenerator.class.getResourceAsStream(schemaPath)) {
            schema = IOUtils.toString(stream, StandardCharsets.UTF_8);
        } catch (final IOException e) {
            throw new RuntimeException("Error reading schema definition from " + schemaPath, e);
        }
        return new ObjectMapper(new YAMLFactory()).readTree(schema);
    }

    private void addPropertyFields(
        final TypeSpec.Builder classBuilder,
        final JsonNode entityDef,
        final String[] path,
        final String parentFieldName
    )
    {
        final Iterator<Entry<String, JsonNode>> propertyIterator = entityDef.fields();

        final boolean isSubfield = path.length > 0;
        final ClassName fieldImplClass = ClassName.get(PACKAGE_NAME, isSubfield ? "SubfieldImpl" : "FieldImpl");
        final Modifier[] fieldOrTypeModifiers = isSubfield ? new Modifier[]{Modifier.PUBLIC, Modifier.FINAL}
            : new Modifier[]{Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL};

        while (propertyIterator.hasNext()) {
            final Entry<String, JsonNode> property = propertyIterator.next();
            final JsonNode fieldAttributes = property.getValue();

            final String propertyName = property.getKey();
            final String ucPropertyName = propertyName.toUpperCase(Locale.US);
            final String sanitizedPropertyName = ucPropertyName.replace('-', '_');

            if (!isSubfield) {
                propertyNames.add(new PropertyNameHelper(propertyName, ucPropertyName, sanitizedPropertyName));
            } else {
                final String subFieldPropertyName = parentFieldName + "." + propertyName;
                final String subFieldUcPropertyName = subFieldPropertyName.toUpperCase(Locale.US);
                final String subFieldSanitizedPropertyName = subFieldUcPropertyName.replace('-', '_');

                propertyNames.add(new PropertyNameHelper(subFieldPropertyName, subFieldUcPropertyName, subFieldSanitizedPropertyName));
            }

            final String fieldType = fieldAttributes.get("type").textValue();

            final int endOfTypeDimension = fieldType.lastIndexOf('[');
            final String fieldTypeValue = endOfTypeDimension > 0 ? fieldType.substring(0, endOfTypeDimension) : fieldType;

            final String fldEncoding
                = fieldAttributes.hasNonNull("objectEncoding")
                ? (fieldAttributes.get("objectEncoding").textValue().equals("json")
                ? "Field.ObjectEncoding.JSON"
                : "Field.ObjectEncoding.FLATTENED")
                : "Field.ObjectEncoding.JSON";
            final boolean fldIsMultiValued = fieldType.endsWith("[]");
            final boolean fldIsMandatory
                = fieldAttributes.hasNonNull("mandatory")
                ? fieldAttributes.get("mandatory").booleanValue()
                : false;
            final boolean fldIsCaseInsensitive
                = fieldAttributes.hasNonNull("ignoreCase")
                ? fieldAttributes.get("ignoreCase").booleanValue()
                : false;
            final boolean fldIsTokenizedPath
                = fieldAttributes.hasNonNull("tokenizedPath")
                ? fieldAttributes.get("tokenizedPath").booleanValue()
                : false;

            if (!PROPERTY_TYPES.contains(fieldType)) {
                final String fieldName = toProperCase(propertyName) + "Field";
                final String[] newPath = addExtraElement(path, fieldName);
                final String fullName = isSubfield ? parentFieldName + "." + propertyName : propertyName;

                final ClassName fieldClassName = ClassName.get(PACKAGE_NAME, CLASS_NAME, newPath);

                final FieldSpec field = FieldSpec.builder(fieldClassName, sanitizedPropertyName)
                    .addModifiers(fieldOrTypeModifiers).addAnnotation(Nonnull.class)
                    .initializer("new $T()", fieldClassName).build();

                final TypeSpec.Builder fieldClassBuiler = TypeSpec.classBuilder(fieldName)
                    .addModifiers(fieldOrTypeModifiers).superclass(fieldImplClass)
                    .addSuperinterface(isSubfield ? StructuredSubfield.class : StructuredField.class)
                    .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE)
                        .addStatement("super($S, $S, $L, $L, $L, $L, $L$L)",
                                      propertyName,
                                      fieldTypeValue,
                                      fldEncoding,
                                      fldIsMultiValued,
                                      fldIsMandatory,
                                      fldIsCaseInsensitive,
                                      fldIsTokenizedPath,
                                      isSubfield ? ", " + path[path.length - 1] + ".this" : "")
                        .build());

                final int endOfTypeName = fieldType.indexOf('[');
                final String refTypeName = endOfTypeName > 0 ? fieldType.substring(0, endOfTypeName) : fieldType;
                final JsonNode subentityDef = typesNode.get(refTypeName);
                addPropertyFields(fieldClassBuiler, subentityDef, newPath, fullName);

                classBuilder.addField(field);
                classBuilder.addType(fieldClassBuiler.build());
            } else {
                final FieldSpec field = FieldSpec
                    .builder(isSubfield ? Subfield.class : Field.class, sanitizedPropertyName)
                    .addModifiers(fieldOrTypeModifiers).addAnnotation(Nonnull.class)
                    .initializer("new $T($S, $S, $L, $L, $L, $L, $L$L)",
                                 fieldImplClass,
                                 propertyName,
                                 fieldTypeValue,
                                 null,
                                 fldIsMultiValued,
                                 fldIsMandatory,
                                 fldIsCaseInsensitive,
                                 fldIsTokenizedPath,
                                 isSubfield ? ", this" : "")
                    .build();

                classBuilder.addField(field);
            }
        }
    }

    private void addPropertyAccessors(final TypeSpec.Builder classBuilder)
    {
        final ParameterSpec paramName = ParameterSpec.builder(String.class, "fieldName").addModifiers(Modifier.FINAL)
            .build();

        final ParameterSpec paramIgnoreCase = ParameterSpec.builder(TypeName.BOOLEAN, "ignoreCase")
            .addModifiers(Modifier.FINAL).build();

        final MethodSpec.Builder getFieldBuilder = MethodSpec.methodBuilder("getField").addModifiers(Modifier.PUBLIC)
            .addModifiers(Modifier.STATIC).returns(Field.class).addParameter(paramName);

        final MethodSpec.Builder getFieldOverloadBuilder = MethodSpec.methodBuilder("getField")
            .addModifiers(Modifier.PUBLIC).addModifiers(Modifier.STATIC).returns(Field.class)
            .addParameter(paramName).addParameter(paramIgnoreCase).beginControlFlow("if (!ignoreCase)")
            .addStatement("return getField(fieldName)").endControlFlow();

        // Start Switch block.
        getFieldBuilder.beginControlFlow("switch (fieldName)");
        getFieldOverloadBuilder.beginControlFlow("switch (fieldName.toUpperCase(java.util.Locale.ENGLISH))");

        for (final PropertyNameHelper helper : propertyNames) {
            addSwitchCase(getFieldBuilder, helper.propertyName, helper.sanitizedPropertyName);
            addSwitchCase(getFieldOverloadBuilder, helper.ucPropertyName, helper.sanitizedPropertyName);
        }

        addSwitchDefault(getFieldBuilder, "fieldName");
        addSwitchDefault(getFieldOverloadBuilder, "fieldName");

        // End switch block.
        getFieldBuilder.endControlFlow();
        getFieldOverloadBuilder.endControlFlow();

        classBuilder.addMethod(getFieldBuilder.build());
        classBuilder.addMethod(getFieldOverloadBuilder.build());
    }

    private void addPropertySetters(
        final Builder objectBuilderClassBuilder,
        MethodSpec.Builder buildFunctionBuilder,
        final JsonNode entityDef,
        final String[] path,
        final String parentFieldName
    )
    {
        final Iterator<Entry<String, JsonNode>> propertyIterator = entityDef.fields();

        final boolean isSubfield = path.length > 0;

        while (propertyIterator.hasNext()) {
            final Entry<String, JsonNode> property = propertyIterator.next();
            final JsonNode fieldAttributes = property.getValue();

            final String propertyName = property.getKey();

            final String fieldType = fieldAttributes.get("type").textValue();

            final int endOfTypeDimension = fieldType.lastIndexOf('[');
            final String fieldTypeValue = endOfTypeDimension > 0 ? fieldType.substring(0, endOfTypeDimension) : fieldType;

            final String fldEncoding
                = fieldAttributes.hasNonNull("objectEncoding")
                ? fieldAttributes.get("objectEncoding").textValue()
                : "json";
                // TODO: flattened does not need build and instance / state variables
            final boolean fldIsMultiValued = fieldType.endsWith("[]");

            // TODO: "ocr[][]" // every additional [] would need a ListBuilder

            final boolean fldIsMandatory
                = fieldAttributes.hasNonNull("mandatory")
                ? fieldAttributes.get("mandatory").booleanValue()
                : false;

            final String fieldFunctionName = toProperCase(propertyName);

            final MethodSpec.Builder clearFieldMethodBuilder = MethodSpec.methodBuilder("clear" + fieldFunctionName)
                .addModifiers(Modifier.PUBLIC);

            if (!PROPERTY_TYPES.contains(fieldType)) {
                // Non-primitive/Object type field
                final String objBuilderClassName = fieldFunctionName + "ObjectBuilder";
                final String[] newPath = addExtraElement(path, objBuilderClassName);
                final String fullName = isSubfield ? parentFieldName + "." + propertyName : propertyName;

                final ParameterizedTypeName builderTypeName = ParameterizedTypeName
                    .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

                final String internalVarName = toFieldNameCase(propertyName);
                final String internalBuilderVarName = internalVarName + "Builder";

                if (parentFieldName.isEmpty()) {
                    // Add set function Builder param
                    addBuilderParamSetter(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        fullName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName);

                    // Add set function with Stream param
                    addBuilderStreamParamSetter(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        fullName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName);

                    // Add clear field method
                    clearFieldMethodBuilder.addStatement("schemaObjectBuilder.clearField($L.$L)", CLASS_NAME, fullName);
                }
                else {
                    final FieldSpec nonPrimitiveField = FieldSpec
                        .builder(
                            fldIsMultiValued
                                ? ParameterizedTypeName.get(
                                    ClassName.get(List.class), ClassName.get("", objBuilderClassName))
                                : ClassName.get("", objBuilderClassName),
                                internalVarName)
                        .addModifiers(new Modifier[]{Modifier.PRIVATE})
                        .build();
                    objectBuilderClassBuilder.addField(nonPrimitiveField);

                    // Add nonPrimitiveField set function Builder param
                    addNestedObjectBuilderParamSetter(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        internalVarName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName);

                    // Add nonPrimitiveField set function with Stream param
                    addNestedObjectBuilderStreamParamSetter(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        internalVarName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName);

                    // Add clear field method
                    clearFieldMethodBuilder.addStatement("$L = null", internalVarName);

                    // Write Json field
                    writeJsonFields(
                        buildFunctionBuilder,
                        fieldTypeValue,
                        fldIsMandatory,
                        fldIsMultiValued,
                        parentFieldName,
                        propertyName,
                        internalVarName,
                        objBuilderClassName);
                }

                // Add set function with List param
                addBuilderListParamSetter(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    builderTypeName,
                    objBuilderClassName,
                    internalBuilderVarName);

                // Add an object builder class for property
                final TypeSpec.Builder fieldObjectBuilderClassBuiler = TypeSpec.classBuilder(objBuilderClassName)
                    .addModifiers(new Modifier[]{Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL})
                    .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE)
                    .build());

                final int endOfTypeName = fieldType.indexOf('[');
                final String refTypeName = endOfTypeName > 0 ? fieldType.substring(0, endOfTypeName) : fieldType;
                final JsonNode subentityDef = typesNode.get(refTypeName);

                // Create a build method
                buildFunctionBuilder = MethodSpec.methodBuilder("build")
                    .addModifiers(Modifier.PRIVATE)
                    .addParameter(ParameterSpec.builder(JsonBuilder.class, "jsonBuilder").addModifiers(Modifier.FINAL).build())
                    .addStatement("jsonBuilder.writeStartObject()");

                // Add all the sub-fields of this non-primitive property
                addPropertySetters(fieldObjectBuilderClassBuiler, buildFunctionBuilder, subentityDef, newPath, fullName);

                buildFunctionBuilder.addStatement("jsonBuilder.writeEndObject()");
                fieldObjectBuilderClassBuiler.addMethod(buildFunctionBuilder.build());

                objectBuilderClassBuilder.addType(fieldObjectBuilderClassBuiler.build());
            } else {
                // Primitive type field
                final ParameterSpec paramSingleFieldValue = ParameterSpec
                    .builder(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue), "value")
                    .addModifiers(Modifier.FINAL)
                    .build();

                final MethodSpec.Builder setSingleFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(paramSingleFieldValue);

                final String subFieldName = toFieldNameCase(propertyName);

                // Add setter variations for multi-valued field
                if (fldIsMultiValued) {
                    // Set array value
                    addArrayParamSetter(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        propertyName,
                        subFieldName,
                        fieldTypeValue,
                        isSubfield);

                    // Set List value
                    addListParamSetter(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        propertyName,
                        subFieldName,
                        fieldTypeValue,
                        isSubfield);

                    // Add single value
                    addSingleValueAddFunction(
                        objectBuilderClassBuilder,
                        paramSingleFieldValue,
                        fieldFunctionName,
                        propertyName,
                        subFieldName,
                        fieldTypeValue,
                        isSubfield);
                }

                if(isSubfield) {
                    // Add instance variable for subField
                    final FieldSpec field = FieldSpec
                        .builder(
                            fldIsMultiValued
                                ? ParameterizedTypeName.get(
                                    ClassName.get(List.class), ClassName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue)))
                                : ClassName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue)),
                            subFieldName)
                        .addModifiers(new Modifier[]{Modifier.PRIVATE})
                        .build();
                    objectBuilderClassBuilder.addField(field);

                    // Add clear function body
                    clearFieldMethodBuilder.addStatement(subFieldName + " = null");

                    // write Json fields
                    writeJsonFields(
                        buildFunctionBuilder,
                        fieldTypeValue,
                        fldIsMandatory,
                        fldIsMultiValued,
                        parentFieldName,
                        propertyName,
                        subFieldName,
                        null);

                    // Add setters for multi-valued subfield
                    if (fldIsMultiValued) {
                        // Add set single value function body
                        setSingleFieldValue.addStatement(
                            "this.$L = new $T()",
                            subFieldName,
                            ParameterizedTypeName
                                .get(ClassName.get(ArrayList.class), TypeName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue))));
                        setSingleFieldValue.addStatement("this.$L.add(value)", subFieldName);
                    } else {
                        setSingleFieldValue.addStatement("this.$L = value", subFieldName);
                    }
                } else {
                    // TODO: how to ensure mandatory field is set?
                    clearFieldMethodBuilder.addStatement("schemaObjectBuilder.clearField($L.$L)", CLASS_NAME, propertyName);

                    setSingleFieldValue.addStatement(
                        "schemaObjectBuilder.set$LFieldValue($L.$L, value)",
                        PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), CLASS_NAME, propertyName);

                }
                // Add single value setter method
                objectBuilderClassBuilder.addMethod(setSingleFieldValue.build());

            }
            // Add clear field method
            objectBuilderClassBuilder.addMethod(clearFieldMethodBuilder.build());
        }
    }

    private static void writeJsonFields(
        final MethodSpec.Builder buildFunctionBuilder,
        final String fieldTypeValue,
        final boolean fldIsMandatory,
        final boolean fldIsMultiValued,
        final String parentFieldName,
        final String propertyName,
        final String subFieldName,
        final String objBuilderClassName)
    {
        if(fldIsMandatory) {
            buildFunctionBuilder
                .beginControlFlow("if ($L == null)", subFieldName)
                .addStatement(
                    "throw new IllegalArgumentException(\"Mandatory field '$L.$L.$L' is not set\")",
                    CLASS_NAME, parentFieldName, propertyName)
                .nextControlFlow("else");
        } else {
            buildFunctionBuilder.beginControlFlow("if ($L != null)", subFieldName);
        }
        buildFunctionBuilder
            .addStatement("jsonBuilder.writeFieldName($L.$L.$L.getFieldName())", CLASS_NAME, parentFieldName, propertyName);

        if (fldIsMultiValued) {
            // Add build function body
            buildFunctionBuilder.addStatement("jsonBuilder.writeStartArray()");

            if (objBuilderClassName == null) {
                buildFunctionBuilder.beginControlFlow(
                    "for(final $L value : $L)", PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), subFieldName);
                buildFunctionBuilder.addStatement(
                    "jsonBuilder.write$L(value)", PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName());
            } else {
                buildFunctionBuilder.beginControlFlow("for(final $L value : $L)", objBuilderClassName, subFieldName);
                buildFunctionBuilder.addStatement("value.build(jsonBuilder)");
            }
            buildFunctionBuilder.endControlFlow();

            buildFunctionBuilder.addStatement("jsonBuilder.writeEndArray()");
        } else {
            buildFunctionBuilder.addStatement(
                "jsonBuilder.write$L($L)", PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), subFieldName);
        }
        buildFunctionBuilder.endControlFlow();
    }

    private static void addBuilderParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "builder")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec setBuilderFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName)
            .addStatement("final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("builder.accept($L)", internalBuilderVarName)
            .addCode("schemaObjectBuilder.setJsonFieldValue(\n")
            .addCode("  $L.$L,\n", CLASS_NAME, propertyName)
            .beginControlFlow("  jsonBuilder ->")
            .addStatement("  $L.build(jsonBuilder)", internalBuilderVarName)
            .endControlFlow()
            .addStatement(")")
            .build();

        objectBuilderClassBuilder.addMethod(setBuilderFieldValue);
    }

    private static void addBuilderStreamParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "builders")
            .addModifiers(Modifier.FINAL)
            .build();
        final MethodSpec setStreamFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName)
            .addCode("schemaObjectBuilder.setJsonFieldValue(\n")
            .addCode("  $L.$L,\n", CLASS_NAME, propertyName)
            .addCode("  builders.<Consumer<JsonBuilder>>map(builder -> {\n")
            .addStatement("    final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("    builder.accept($L)", internalBuilderVarName)
            .addCode("    return jsonBuilder -> {\n")
            .addStatement("      $L.build(jsonBuilder)", internalBuilderVarName)
            .addStatement("    }")
            .addStatement("}))")
            .build();

        objectBuilderClassBuilder.addMethod(setStreamFieldValue);
    }

    private static void addBuilderListParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(List.class), builderTypeName), "builders")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec setListFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName)
            .addStatement("set$L(builders.stream())", fieldFunctionName)
            .build();

        objectBuilderClassBuilder.addMethod(setListFieldValue);
    }

    private static void addNestedObjectBuilderParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String internalVarName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "builder")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec setBuilderFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName)
            .addStatement("final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("builder.accept($L)", internalBuilderVarName)
            .addStatement("$L = new ArrayList<>()", internalVarName)
            .addStatement("$L.add($L)", internalVarName, internalBuilderVarName)
            .build();

        objectBuilderClassBuilder.addMethod(setBuilderFieldValue);
    }

    private static void addNestedObjectBuilderStreamParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String internalVarName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "builders")
            .addModifiers(Modifier.FINAL)
            .build();
        final MethodSpec setStreamFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName)
            .addCode("$L = builders.map(builder -> {\n", internalVarName)
            .addStatement("  final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("  builder.accept($L)", internalBuilderVarName)
            .addStatement("  return $L", internalBuilderVarName)
            .addStatement("}).collect($T.toList())", Collectors.class)
            .build();

        objectBuilderClassBuilder.addMethod(setStreamFieldValue);
    }

    private static void addArrayParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield
    )
    {
        final ParameterSpec arrayParamFieldName = ParameterSpec
            .builder( ArrayTypeName.of(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue)), "values")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setArrayFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(arrayParamFieldName)
            .varargs(true);

        if (isSubfield) {
            setArrayFieldValue.addStatement("this.$L = $T.asList(values)", subFieldName, Arrays.class);
        } else {
            setArrayFieldValue.addStatement(
                "schemaObjectBuilder.set$LFieldValue($L.$L, values)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), CLASS_NAME, propertyName);
        }
        objectBuilderClassBuilder.addMethod(setArrayFieldValue.build());
    }

    private static void addListParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield
    )
    {
        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(
                ParameterizedTypeName.get(ClassName.get(List.class), TypeName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue))),
                "values")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setListFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName);

        if (isSubfield) {
            setListFieldValue.addStatement("this.$L = values", subFieldName);
        } else {
            setListFieldValue.addStatement(
                "schemaObjectBuilder.set$LFieldValue($L.$L, values)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), CLASS_NAME, propertyName);
        }

        objectBuilderClassBuilder.addMethod(setListFieldValue.build());
    }

    private static void addSingleValueAddFunction(
        final Builder objectBuilderClassBuilder,
        final ParameterSpec paramSingleFieldValue,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield
    )
    {
        final MethodSpec.Builder addFieldValue = MethodSpec.methodBuilder("add" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(paramSingleFieldValue);

        if (isSubfield) {
            addFieldValue.beginControlFlow("if ($L == null)", subFieldName);
            addFieldValue.addStatement(
                "this.$L = new $T()",
                subFieldName,
                ParameterizedTypeName.get(ClassName.get(ArrayList.class), TypeName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue))));
            addFieldValue.endControlFlow();
            addFieldValue.addStatement("this.$L.add(value)", subFieldName);
        } else {
            addFieldValue.addStatement(
                "schemaObjectBuilder.add$LFieldValue($L.$L, value)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), CLASS_NAME, propertyName);
        }

        objectBuilderClassBuilder.addMethod(addFieldValue.build());
    }

    private static void addSwitchCase(
        final MethodSpec.Builder builder,
        final String caseValue,
        final String returnValue
    )
    {
        builder.addCode("case $S:\n", caseValue).addStatement("  return $L", returnValue);
    }

    private static void addSwitchDefault(final MethodSpec.Builder builder, final String fieldName)
    {
        builder.addCode("default:\n").addStatement("  throw new FieldNotFoundException($L)", fieldName);
    }

    private static String toProperCase(final String str)
    {
        return StringUtils
            .capitaliseAllWords(str.replace('_', ' ').replace('-', ' ').toLowerCase(Locale.US))
            .replace(" ", "");
    }

    private static String toFieldNameCase(final String str)
    {
        return StringUtils.lowercaseFirstLetter(toProperCase(str));
    }

    private static String[] addExtraElement(final String[] element, final String extraElement)
    {
        final String[] newPath = Arrays.copyOf(element, element.length + 1);
        newPath[element.length] = extraElement;
        return newPath;
    }
}
