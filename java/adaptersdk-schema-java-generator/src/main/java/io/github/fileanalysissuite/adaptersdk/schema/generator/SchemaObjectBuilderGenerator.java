/*
 * Copyright 2022 Micro Focus or one of its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.fileanalysissuite.adaptersdk.schema.generator;

import com.fasterxml.jackson.databind.JsonNode;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeSpec.Builder;

import io.github.fileanalysissuite.adaptersdk.schema.builders.JsonBuilder;
import io.github.fileanalysissuite.adaptersdk.schema.builders.SchemaObjectBuilder;
import java.io.IOException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import org.codehaus.plexus.util.StringUtils;

final class SchemaObjectBuilderGenerator
{
    private static final String BUILDER_CLASS_NAME = "AdapterSdkSchemaObjectBuilder";
    private static final Map<String, Class> PROPERTY_TYPES_LOOKUP = new HashMap<String, Class>() {
        {
            put("STRING", String.class);
            put("FULLTEXT", String.class);
            put("LONG", Long.class);
            put("DOUBLE", Double.class);
            put("INTEGER", Integer.class);
            put("BOOLEAN", Boolean.class);
            put("DATETIME", Instant.class);
        }
    };

    private final Filer filer;
    private final JsonNode schemaNode;
    private JsonNode typesNode;

    public SchemaObjectBuilderGenerator(final Filer filer, final JsonNode schemaNode)
    {
        this.filer = filer;
        this.schemaNode = schemaNode;
        this.typesNode = schemaNode.get("types");
    }

    public boolean process()
    {
        final TypeSpec.Builder schemaClassBuilder
            = createSchemaObjectBuilderClass(
                BUILDER_CLASS_NAME, null, null, schemaNode.get("fields"), new String[0], new String(), true, false);

        final JavaFile javaFile = JavaFile.builder(SchemaGeneratorHelper.PACKAGE_NAME, schemaClassBuilder.build())
            .addFileComment("\nThis file is auto-generated by SchemaGenerator\n").build();

        try {
            javaFile.writeTo(filer);
        } catch (final IOException e) {
            throw new RuntimeException("Unable to write out generated schema builder file", e);
        }
        return false;
    }

    private TypeSpec.Builder createSchemaObjectBuilderClass(
        final String builderClassName,
        final MethodSpec.Builder buildFunctionBuilder,
        MethodSpec.Builder validateFunctionBuilder,
        final JsonNode schemaNode,
        final String[] path,
        final String parentFieldName,
        final boolean flattenedParentField,
        final boolean isStatic)
    {
        final Modifier[] modifiers = isStatic
            ? new Modifier[]{Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL}
            : new Modifier[]{Modifier.PUBLIC, Modifier.FINAL};
        final TypeSpec.Builder schemaClassBuilder = TypeSpec.classBuilder(builderClassName)
            .addModifiers(modifiers);

        addSchemaObjectBuilderFieldAndCtor(schemaClassBuilder);

        // Create a 'validate' method
        final MethodSpec.Builder parentValidator = validateFunctionBuilder == null ? null : validateFunctionBuilder;

        validateFunctionBuilder = MethodSpec.methodBuilder("validate")
            .addModifiers(Modifier.PRIVATE);

        addPropertySetters(
            schemaClassBuilder, buildFunctionBuilder, validateFunctionBuilder, schemaNode, path, parentFieldName, flattenedParentField);

        schemaClassBuilder.addMethod(validateFunctionBuilder.build());

        if (parentValidator != null) {
            validateFunctionBuilder = parentValidator;
        }

        return schemaClassBuilder;
    }

    private static void addSchemaObjectBuilderFieldAndCtor(final TypeSpec.Builder schemaClassBuilder)
    {
        final FieldSpec field = FieldSpec
            .builder(SchemaObjectBuilder.class, "schemaObjectBuilder")
            .addModifiers(Modifier.PRIVATE, Modifier.FINAL)
            .build();

        schemaClassBuilder.addField(field);

        final MethodSpec constructor = MethodSpec
            .constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addParameter(SchemaObjectBuilder.class, "schemaObjectBuilder", Modifier.FINAL)
            .addStatement("this.schemaObjectBuilder = schemaObjectBuilder")
            .build();

        schemaClassBuilder.addMethod(constructor);
    }

    private void addPropertySetters(
        final TypeSpec.Builder objectBuilderClassBuilder,
        MethodSpec.Builder buildFunctionBuilder,
        MethodSpec.Builder validateFunctionBuilder,
        final JsonNode entityDef,
        final String[] path,
        final String parentFieldName,
        final boolean flattenedParentField
    )
    {
        /*
            flattened + json + flattened ====> not possible
            flattened + flattened
            flattened + json
            flattened + flattened + flattened + flattened + json
            json + json + json - starts with json, all nested entities have to be json
        */
        final Iterator<Entry<String, JsonNode>> propertyIterator = entityDef.fields();

        final boolean isSubfield = path.length > 0;

        while (propertyIterator.hasNext()) {
            final Entry<String, JsonNode> property = propertyIterator.next();
            final JsonNode fieldAttributes = property.getValue();

            final String propertyName = property.getKey();

            final String fieldType = fieldAttributes.get("type").textValue();

            final int endOfTypeDimension = fieldType.lastIndexOf('[');

            final String fieldTypeValue = endOfTypeDimension > 0 ? fieldType.substring(0, endOfTypeDimension) : fieldType;

            final int numberOfDimensions = endOfTypeDimension > 0 ? StringUtils.countMatches(fieldType, "[]") : 0;

            final boolean isFlattened
                = fieldAttributes.hasNonNull("objectEncoding")
                ? fieldAttributes.get("objectEncoding").textValue().equals("flattened")
                : false;

            final boolean fldIsMultiValued = fieldType.endsWith("[]");

            final boolean fldIsMandatory
                = fieldAttributes.hasNonNull("mandatory")
                ? fieldAttributes.get("mandatory").booleanValue()
                : false;

            final String fieldFunctionName = SchemaGeneratorHelper.toProperCase(propertyName);

            if (!SchemaGeneratorHelper.PROPERTY_TYPES.contains(fieldType)) {
                // Non-primitive/Object type field
                addEntityTypePropertySetters(
                    objectBuilderClassBuilder,
                    buildFunctionBuilder,
                    validateFunctionBuilder,
                    fieldFunctionName,
                    fieldType,
                    fieldTypeValue,
                    fldIsMandatory,
                    fldIsMultiValued,
                    numberOfDimensions,
                    isSubfield,
                    path,
                    propertyName,
                    parentFieldName,
                    isFlattened,
                    flattenedParentField
                );
            } else {
                // Primitive type field
                addNonEntityTypePropertySetterMethods(
                    objectBuilderClassBuilder,
                    buildFunctionBuilder,
                    validateFunctionBuilder,
                    fieldFunctionName,
                    fieldTypeValue,
                    fldIsMandatory,
                    fldIsMultiValued,
                    isSubfield,
                    propertyName,
                    parentFieldName,
                    flattenedParentField
                );
            }
        }
    }

    private void addEntityTypePropertySetters(
        final TypeSpec.Builder objectBuilderClassBuilder,
        MethodSpec.Builder buildFunctionBuilder,
        MethodSpec.Builder validateFunctionBuilder,
        final String fieldFunctionName,
        final String fieldType,
        final String fieldTypeValue,
        final boolean fldIsMandatory,
        final boolean fldIsMultiValued,
        final int numberOfDimensions,
        final boolean isSubfield,
        final String[] path,
        final String propertyName,
        final String parentFieldName,
        final boolean isFlattened,
        final boolean flattenedParentField
    )
    {
        final String objBuilderClassName = fieldFunctionName + "ObjectBuilder";
        final int endOfTypeName = fieldType.indexOf('[');
        final String refTypeName = endOfTypeName > 0 ? fieldType.substring(0, endOfTypeName) : fieldType;
        final JsonNode subentityDef = typesNode.get(refTypeName);

        final String[] newPath = SchemaGeneratorHelper.addExtraElement(path, objBuilderClassName);
        final String fullName = isSubfield ? parentFieldName + "." + propertyName : propertyName;

        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final String internalVarName = SchemaGeneratorHelper.toFieldNameCase(propertyName);
        final String internalBuilderVarName = internalVarName + "Builder";

        // Add clear field method body
        final MethodSpec.Builder clearFieldMethodBuilder = MethodSpec.methodBuilder("clear" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC);

        // TODO: call validate in setters of flattened entity type properties of main schema,

        // Add setters, clear, and list object builder classes
        // "ocr[][]" // every additional dimension would need a ListBuilder
        final String validatorSubFieldName = "is" + SchemaGeneratorHelper.toProperCase(internalBuilderVarName) + "Set";
        if(numberOfDimensions > 1) {
            addMultiDimensionalEntityTypeProperty(
                objectBuilderClassBuilder,
                objBuilderClassName,
                internalBuilderVarName,
                fieldFunctionName,
                fullName,
                internalVarName,
                numberOfDimensions,
                isFlattened,
                fldIsMandatory,
                validatorSubFieldName
            );
            // Add 'clear' field method body
            clearFieldMethodBuilder
                .addStatement("schemaObjectBuilder.clearField($L.$L)", SchemaGeneratorHelper.CLASS_NAME, fullName);
        } else {
            // Single dimension field
            if(isFlattened) {
                // Sub entity is flattened
                // Add entity type field 'set' function with 'Builder' param
                addBuilderParamSetterMethod(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    fullName,
                    builderTypeName,
                    objBuilderClassName,
                    internalBuilderVarName,
                    isFlattened,
                    fldIsMandatory,
                    validatorSubFieldName);

                // Add entity type field 'set' function with 'Stream' param
                addBuilderStreamParamSetterMethod(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    fullName,
                    builderTypeName,
                    objBuilderClassName,
                    internalBuilderVarName,
                    isFlattened,
                    fldIsMandatory,
                    validatorSubFieldName);

                // Add 'set' function with 'List' param
                addBuilderListParamSetterMethod(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    builderTypeName,
                    objBuilderClassName,
                    internalBuilderVarName);

                // Add 'clear' field method body
                clearFieldMethodBuilder
                    .addStatement("schemaObjectBuilder.clearField($L.$L)", SchemaGeneratorHelper.CLASS_NAME, fullName);

                if (fldIsMandatory) {
                    // Add instance variable for checking if subField is set
                    addValidateField(objectBuilderClassBuilder, validatorSubFieldName);

                    // TODO: Note that mandatory field is set in all the setters
                    // setSingleFieldValueMethodBuilder.addStatement("$L = true", subFieldNameCheck);
                    // Note that mandatory field is reset
                    clearFieldMethodBuilder.addStatement("$L = false", validatorSubFieldName);

                    // add field to validate method
                    checkFieldsInValidateMethod(
                        validateFunctionBuilder,
                        parentFieldName,
                        propertyName,
                        validatorSubFieldName);
                }

            } else {
                // Sub entity is json encoded
                if (flattenedParentField) {
                    // parent is flattened, but this sub entity is not
                    buildFunctionBuilder = MethodSpec.methodBuilder("build")
                        .addModifiers(Modifier.PRIVATE)
                        .addParameter(ParameterSpec.builder(JsonBuilder.class, "jsonBuilder").addModifiers(Modifier.FINAL).build())
                        .addStatement("jsonBuilder.writeStartObject()");
                    // Add entity type property 'set' function 'Builder' param
                    addBuilderParamSetterMethod(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        fullName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName,
                        isFlattened,
                        fldIsMandatory,
                        validatorSubFieldName);

                    // Add entity type property 'set' function with 'Stream' param
                    addBuilderStreamParamSetterMethod(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        fullName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName,
                        isFlattened,
                        fldIsMandatory,
                        validatorSubFieldName);

                    // Add 'clear' field method body
                    clearFieldMethodBuilder
                        .addStatement("schemaObjectBuilder.clearField($L.$L)", SchemaGeneratorHelper.CLASS_NAME, fullName);
                } else {
                    // parent is json encoded, this sub entity is also json encoded
                    final FieldSpec nonPrimitiveField = FieldSpec
                        .builder(
                            fldIsMultiValued
                                ? ParameterizedTypeName.get(
                                    ClassName.get(List.class), ClassName.get("", objBuilderClassName))
                                : ClassName.get("", objBuilderClassName),
                                internalVarName)
                        .addModifiers(new Modifier[]{Modifier.PRIVATE})
                        .build();
                    objectBuilderClassBuilder.addField(nonPrimitiveField);

                    // Add entity type property 'set' function 'Builder' param
                    addNestedObjectBuilderParamSetterMethod(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        internalVarName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName,
                        isFlattened);

                    // Add entity type property 'set' function with 'Stream' param
                    addNestedObjectBuilderStreamParamSetterMethod(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        internalVarName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName,
                        isFlattened);

                    // Add 'clear' field method body
                    clearFieldMethodBuilder.addStatement("$L = null", internalVarName);
                }

                // Write Json field
                writeJsonFieldsInBuildMethod(
                    buildFunctionBuilder,
                    fieldTypeValue,
                    fldIsMandatory,
                    fldIsMultiValued,
                    parentFieldName,
                    propertyName,
                    internalVarName,
                    objBuilderClassName);

                // Add set function with List param
                addBuilderListParamSetterMethod(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    builderTypeName,
                    objBuilderClassName,
                    internalBuilderVarName);
            }
        }

        // Add an object builder class for entity type property
        addEntityTypeObjectBuilderClass(
            objectBuilderClassBuilder,
            objBuilderClassName,
            buildFunctionBuilder,
            validateFunctionBuilder,
            subentityDef,
            newPath,
            fullName,
            isFlattened);

        // Add clear field method
        objectBuilderClassBuilder.addMethod(clearFieldMethodBuilder.build());
    }

    private static void addValidateField(final TypeSpec.Builder objectBuilderClassBuilder, final String fieldNameCheck)
    {
        final FieldSpec validateField = FieldSpec
            .builder(
                TypeName.BOOLEAN,
                fieldNameCheck)
            .addModifiers(new Modifier[]{Modifier.PRIVATE})
            .build();
        objectBuilderClassBuilder.addField(validateField);
    }

    private static void addMultiDimensionalEntityTypeProperty(
        final TypeSpec.Builder objectBuilderClassBuilder,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final String fieldFunctionName,
        final String fullName,
        final String internalVarName,
        final int numberOfDimensions,
        final boolean isFlattened,
        final boolean isFieldMandatory,
        final String validatorSubFieldName
    )
    {
        // Multi-dimensional field
        // Add an list object builder class for property
        final String suffix = "ObjectBuilder";
        String listName = "";
        for(int i = 0; i < numberOfDimensions - 1; i++) {
            listName += "List";
            addListBuilderClass(
                objectBuilderClassBuilder,
                objBuilderClassName,
                fieldFunctionName + listName + suffix,
                internalVarName,
                isFlattened);
        }
        final String listObjBuilderClassName = fieldFunctionName + listName + suffix;
        final ParameterizedTypeName listBuilderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", listObjBuilderClassName));

        // Add 'set' function with 'Builder' param
        addBuilderParamSetterMethod(
            objectBuilderClassBuilder,
            fieldFunctionName,
            fullName,
            listBuilderTypeName,
            listObjBuilderClassName,
            internalBuilderVarName,
            isFlattened,
            isFieldMandatory,
            validatorSubFieldName);

        // Add 'set' function with 'Stream' param
        addBuilderStreamParamSetterMethod(
            objectBuilderClassBuilder,
            fieldFunctionName,
            fullName,
            listBuilderTypeName,
            listObjBuilderClassName,
            internalBuilderVarName,
            isFlattened,
            isFieldMandatory,
            validatorSubFieldName);

        // Add 'set' function with 'List' param
        addBuilderListParamSetterMethod(
            objectBuilderClassBuilder,
            fieldFunctionName,
            listBuilderTypeName,
            listObjBuilderClassName,
            internalBuilderVarName);
    }

    private void addEntityTypeObjectBuilderClass(
        final TypeSpec.Builder objectBuilderClassBuilder,
        final String objBuilderClassName,
        MethodSpec.Builder buildFunctionBuilder,
        MethodSpec.Builder validateFunctionBuilder,
        final JsonNode subentityDef,
        final String[] newPath,
        final String fullName,
        final boolean isFlattened
    )
    {
        if(isFlattened) {
            final TypeSpec.Builder fieldObjectBuilderClassBuilder
                = createSchemaObjectBuilderClass(
                    objBuilderClassName, buildFunctionBuilder, validateFunctionBuilder, subentityDef, newPath, fullName, true, true);

            objectBuilderClassBuilder.addType(fieldObjectBuilderClassBuilder.build());
        } else {
            // This class will have instance variables for each property and a 'build' function to write json values
            final TypeSpec.Builder fieldObjectBuilderClassBuilder = TypeSpec.classBuilder(objBuilderClassName)
            .addModifiers(new Modifier[]{Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL})
            .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE)
            .build());

            // Create a 'build' method
            final MethodSpec.Builder parentBuilder = buildFunctionBuilder == null ? null : buildFunctionBuilder;
            buildFunctionBuilder = MethodSpec.methodBuilder("build")
                .addModifiers(Modifier.PRIVATE)
                .addParameter(ParameterSpec.builder(JsonBuilder.class, "jsonBuilder").addModifiers(Modifier.FINAL).build())
                .addStatement("jsonBuilder.writeStartObject()");

            // Add all the sub-fields of this entity type property
            addPropertySetters(
                fieldObjectBuilderClassBuilder, buildFunctionBuilder, validateFunctionBuilder, subentityDef, newPath, fullName, false);

            buildFunctionBuilder.addStatement("jsonBuilder.writeEndObject()");
            fieldObjectBuilderClassBuilder.addMethod(buildFunctionBuilder.build());
            if (parentBuilder != null) {
                buildFunctionBuilder = parentBuilder;
            }
            objectBuilderClassBuilder.addType(fieldObjectBuilderClassBuilder.build());
        }
    }

    private static void addListBuilderClass(
        final TypeSpec.Builder objectBuilderClassBuilder,
        final String objBuilderClassName,
        final String listObjBuilderClassName,
        final String internalVarName,
        final boolean isFlattened
    )
    {
        final TypeSpec.Builder fieldListObjectBuilderClassBuiler = TypeSpec.classBuilder(listObjBuilderClassName)
            .addModifiers(new Modifier[]{Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL});
        // flattened does not need 'build' function and instance/state variables
        if (isFlattened) {
            addSchemaObjectBuilderFieldAndCtor(fieldListObjectBuilderClassBuiler);

            // Add 'set' function with 'Builder' param
            addFieldListObjectBuilderBuilderParamSetterMethod(
                fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName);

            // Add 'set' function with 'Stream' param
            addFieldListObjectBuilderStreamParamSetterMethod(
                fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName);

            // Add 'set' function with 'List' param
            addFieldListObjectBuilderListParamSetterMethod(fieldListObjectBuilderClassBuiler, objBuilderClassName);

            // Add 'clear' field method
            addFieldListObjectBuilderClearMethod(fieldListObjectBuilderClassBuiler);
        } else {
            // Json encoded
            fieldListObjectBuilderClassBuiler.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build());

            // Add instance variable for list of field object builders
            final String listName = internalVarName + "Builders";
            final FieldSpec fieldObjBuilderList = FieldSpec
                .builder(ParameterizedTypeName.get(
                    ClassName.get(List.class), ClassName.get("", objBuilderClassName)), listName)
                .addModifiers(new Modifier[]{Modifier.PRIVATE})
                .build();
            fieldListObjectBuilderClassBuiler.addField(fieldObjBuilderList);

            // Add 'set' function with 'Builder' param
            addFieldListObjectBuilderBuilderParamSetter(
                fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName, listName);

            // Add 'set' function with 'Stream' param
            addFieldListObjectBuilderStreamParamSetter(
                fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName, listName);

            // Add 'set' function with 'List' param
            addFieldListObjectBuilderListParamSetterMethod(fieldListObjectBuilderClassBuiler, objBuilderClassName);

            // Add 'clear' field method
            addFieldListObjectBuilderClearMethod(fieldListObjectBuilderClassBuiler, listName);

            // Add 'build' method
            addFieldListObjectBuilderBuildMethod(fieldListObjectBuilderClassBuiler, objBuilderClassName, listName);
        }

        objectBuilderClassBuilder.addType(fieldListObjectBuilderClassBuiler.build());
    }

    private static void addNonEntityTypePropertySetterMethods(
        final TypeSpec.Builder objectBuilderClassBuilder,
        final MethodSpec.Builder buildFunctionBuilder,
        final MethodSpec.Builder validateFunctionBuilder,
        final String fieldFunctionName,
        final String fieldTypeValue,
        final boolean fldIsMandatory,
        final boolean fldIsMultiValued,
        final boolean isSubfield,
        final String propertyName,
        final String parentFieldName,
        final boolean flattenedParentField)
    {
        final ParameterSpec paramSingleFieldValue = ParameterSpec
            .builder(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue), "value")
            .addModifiers(Modifier.FINAL)
            .build();

        final String subFieldName = SchemaGeneratorHelper.toFieldNameCase(propertyName);
        final String validatorSubFieldName = "is" + SchemaGeneratorHelper.toProperCase(subFieldName)+ "Set";

        // Add setter variations for multi-valued field
        if (fldIsMultiValued) {
            // Set 'array' value
            addArrayParamSetterMethod(
                objectBuilderClassBuilder,
                fieldFunctionName,
                propertyName,
                subFieldName,
                fieldTypeValue,
                isSubfield,
                parentFieldName,
                flattenedParentField,
                fldIsMandatory,
                validatorSubFieldName);

            // Set 'List' value
            addListParamSetterMethod(
                objectBuilderClassBuilder,
                fieldFunctionName,
                propertyName,
                subFieldName,
                fieldTypeValue,
                isSubfield,
                parentFieldName,
                flattenedParentField,
                fldIsMandatory,
                validatorSubFieldName);

            // Add 'single' value
            addSingleValueAddMethod(
                objectBuilderClassBuilder,
                paramSingleFieldValue,
                fieldFunctionName,
                propertyName,
                subFieldName,
                fieldTypeValue,
                isSubfield,
                parentFieldName,
                flattenedParentField,
                fldIsMandatory,
                validatorSubFieldName);
        }

        final MethodSpec.Builder setSingleFieldValueMethodBuilder = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(paramSingleFieldValue);

        final MethodSpec.Builder clearFieldMethodBuilder = MethodSpec.methodBuilder("clear" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC);

        if (isSubfield) {
            // This is a non entity type property of an entity type property
            if (flattenedParentField) {
                clearFieldMethodBuilder
                    .addStatement(
                        "schemaObjectBuilder.clearField($L.$L)",
                        SchemaGeneratorHelper.CLASS_NAME, parentFieldName + "." + propertyName);

                setSingleFieldValueMethodBuilder.addStatement(
                    "schemaObjectBuilder.set$LFieldValue($L.$L, value)",
                    PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(),
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName + "." + propertyName);

                if (fldIsMandatory) {
                    // Add instance variable for checking if subField is set
                    addValidateField(objectBuilderClassBuilder, validatorSubFieldName);

                    // Note that mandatory field is set
                    setSingleFieldValueMethodBuilder.addStatement("$L = true", validatorSubFieldName);
                    // Note that mandatory field is reset
                    clearFieldMethodBuilder.addStatement("$L = false", validatorSubFieldName);

                    // add field to validate method
                    checkFieldsInValidateMethod(
                        validateFunctionBuilder,
                        parentFieldName,
                        propertyName,
                        validatorSubFieldName);
                }
            } else {
                // Add instance variable for subField
                final FieldSpec field = FieldSpec
                    .builder(
                        fldIsMultiValued
                            ? ParameterizedTypeName.get(
                                ClassName.get(List.class), ClassName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue)))
                            : ClassName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue)),
                        subFieldName)
                    .addModifiers(new Modifier[]{Modifier.PRIVATE})
                    .build();
                objectBuilderClassBuilder.addField(field);

                // Add 'clear' function body
                clearFieldMethodBuilder.addStatement(subFieldName + " = null");

                // write Json fields
                writeJsonFieldsInBuildMethod(
                    buildFunctionBuilder,
                    fieldTypeValue,
                    fldIsMandatory,
                    fldIsMultiValued,
                    parentFieldName,
                    propertyName,
                    subFieldName,
                    null);

                // Add setters for multi-valued subfield
                if (fldIsMultiValued) {
                    // Add set single value function body
                    setSingleFieldValueMethodBuilder.addStatement(
                        "this.$L = new $T()",
                        subFieldName,
                        ParameterizedTypeName
                            .get(ClassName.get(ArrayList.class), TypeName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue))));
                    setSingleFieldValueMethodBuilder.addStatement("this.$L.add(value)", subFieldName);
                } else {
                    setSingleFieldValueMethodBuilder.addStatement("this.$L = value", subFieldName);
                }
            }
        } else {
            // This is a non entity type property in the main schema
            clearFieldMethodBuilder
                .addStatement("schemaObjectBuilder.clearField($L.$L)", SchemaGeneratorHelper.CLASS_NAME, propertyName);

            setSingleFieldValueMethodBuilder.addStatement(
                "schemaObjectBuilder.set$LFieldValue($L.$L, value)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), SchemaGeneratorHelper.CLASS_NAME, propertyName);

        }
        // Add 'single value' setter method
        objectBuilderClassBuilder.addMethod(setSingleFieldValueMethodBuilder.build());

        // Add 'clear' field method
        objectBuilderClassBuilder.addMethod(clearFieldMethodBuilder.build());
    }

    private static void addFieldListObjectBuilderBuilderParamSetter(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName,
        final String listName
    )
    {
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "director")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec.Builder setBuilderFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName);
        setBuilderFieldValue
                .addStatement("final $L $L = new $L()", objBuilderClassName, varName, objBuilderClassName);
        setBuilderFieldValue.addStatement("director.accept($L)", varName)
            .addStatement("$L = new ArrayList<>()", listName)
            .addStatement("$L.add($L)", listName, varName);

        fieldListObjectBuilderClassBuiler.addMethod(setBuilderFieldValue.build());
    }

    private static void addFieldListObjectBuilderBuilderParamSetterMethod(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName
    )
    {
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "director")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec.Builder setBuilderFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName);

        setBuilderFieldValue
            .addCode("this.schemaObjectBuilder.setFlattenedFieldValue(null, builder -> {\n")
            .addStatement("    final $L $L = new $L(builder)", objBuilderClassName, varName, objBuilderClassName)
            .addStatement("    director.accept($L)", varName)
            .addStatement("    $L.validate()", varName)
            .addStatement("})");

        fieldListObjectBuilderClassBuiler.addMethod(setBuilderFieldValue.build());
    }

    private static void addFieldListObjectBuilderStreamParamSetter(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName,
        final String listName
    )
    {
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec.Builder setStreamFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName)
            .addCode("$L = directors.map(director -> {\n", listName);
        setStreamFieldValue
            .addStatement("  final $L $L = new $L()", objBuilderClassName, varName, objBuilderClassName);

        setStreamFieldValue.addStatement("  director.accept($L)", varName)
            .addStatement("  return $L", varName)
            .addStatement("}).collect($T.toList())", Collectors.class);

        fieldListObjectBuilderClassBuiler.addMethod(setStreamFieldValue.build());
    }

    private static void addFieldListObjectBuilderStreamParamSetterMethod(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName
    )
    {
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec.Builder setStreamFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName);

        setStreamFieldValue
        .addCode("this.schemaObjectBuilder.setFlattenedFieldValue(null, directors.map(director -> builder -> {\n")
        .addStatement("    final $L $L = new $L(builder)", objBuilderClassName, varName, objBuilderClassName)
        .addStatement("    director.accept($L)", varName)
        .addStatement("    $L.validate()", varName)
        .addStatement("}))");

        fieldListObjectBuilderClassBuiler.addMethod(setStreamFieldValue.build());
    }

    private static void addFieldListObjectBuilderListParamSetterMethod(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName
    )
    {
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(List.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec setBuilderFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName)
            .addStatement("set(directors.stream())")
            .build();

        fieldListObjectBuilderClassBuiler.addMethod(setBuilderFieldValue);
    }

    private static void addFieldListObjectBuilderClearMethod(
        final Builder fieldListObjectBuilderClassBuiler,
        final String listName
    )
    {
        final MethodSpec setBuilderFieldValue = MethodSpec.methodBuilder("clear")
            .addModifiers(Modifier.PUBLIC)
            .addStatement("$L = null", listName)
            .build();

        fieldListObjectBuilderClassBuiler.addMethod(setBuilderFieldValue);
    }

    private static void addFieldListObjectBuilderClearMethod(
        final Builder fieldListObjectBuilderClassBuiler
    )
    {
        final MethodSpec setBuilderFieldValue = MethodSpec.methodBuilder("clear")
            .addModifiers(Modifier.PUBLIC)
            .addStatement("this.schemaObjectBuilder.clearField(null)")
            .build();

        fieldListObjectBuilderClassBuiler.addMethod(setBuilderFieldValue);
    }

    private static void addFieldListObjectBuilderBuildMethod(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String listName
    )
    {
        final MethodSpec buildFunctionBuilder = MethodSpec.methodBuilder("build")
            .addModifiers(Modifier.PRIVATE)
            .addParameter(ParameterSpec.builder(JsonBuilder.class, "jsonBuilder")
            .addModifiers(Modifier.FINAL).build())
            .addStatement("jsonBuilder.writeStartArray()")
            .beginControlFlow("if ($L != null)", listName)
            .beginControlFlow("for (final $L value : $L)", objBuilderClassName, listName)
            .addStatement("value.build(jsonBuilder)")
            .endControlFlow()
            .endControlFlow()
            .addStatement("jsonBuilder.writeEndArray()")
            .build();

        fieldListObjectBuilderClassBuiler.addMethod(buildFunctionBuilder);
    }

    private static void checkFieldsInValidateMethod(
        final MethodSpec.Builder validateFunctionBuilder,
        final String parentFieldName,
        final String propertyName,
        final String validatorSubFieldName)
    {
        validateFunctionBuilder
            .beginControlFlow("if (!$L)", validatorSubFieldName)
            .addStatement(
                "throw new IllegalArgumentException(\"Mandatory field '$L.$L.$L' is not set\")",
                SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName)
            .endControlFlow();
    }

    private static void writeJsonFieldsInBuildMethod(
        final MethodSpec.Builder buildFunctionBuilder,
        final String fieldTypeValue,
        final boolean fldIsMandatory,
        final boolean fldIsMultiValued,
        final String parentFieldName,
        final String propertyName,
        final String subFieldName,
        final String objBuilderClassName)
    {
        if(fldIsMandatory) {
            buildFunctionBuilder
                .beginControlFlow("if ($L == null)", subFieldName)
                .addStatement(
                    "throw new IllegalArgumentException(\"Mandatory field '$L.$L.$L' is not set\")",
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName)
                .nextControlFlow("else");
        } else {
            buildFunctionBuilder.beginControlFlow("if ($L != null)", subFieldName);
        }
        buildFunctionBuilder.addStatement(
            "jsonBuilder.writeFieldName($L.$L.$L.getFieldName())", SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName);

        if (fldIsMultiValued) {
            // Add 'build' function body
            buildFunctionBuilder.addStatement("jsonBuilder.writeStartArray()");

            if (objBuilderClassName == null) {
                buildFunctionBuilder.beginControlFlow(
                    "for(final $L value : $L)", PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), subFieldName);
                buildFunctionBuilder.addStatement(
                    "jsonBuilder.write$L(value)", PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName());
            } else {
                buildFunctionBuilder.beginControlFlow("for(final $L value : $L)", objBuilderClassName, subFieldName);
                buildFunctionBuilder.addStatement("value.build(jsonBuilder)");
            }
            buildFunctionBuilder.endControlFlow();

            buildFunctionBuilder.addStatement("jsonBuilder.writeEndArray()");
        } else {
            buildFunctionBuilder.addStatement(
                "jsonBuilder.write$L($L)", PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), subFieldName);
        }
        buildFunctionBuilder.endControlFlow();
    }

    private static void addBuilderParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFlattened,
        final boolean isFldMandatory,
        final String validatorSubFieldName
    )
    {
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "director")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setBuilderFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName);
        if (isFlattened) {
            setBuilderFieldValue
            .addCode("schemaObjectBuilder.setFlattenedFieldValue($L.$L, sBuilder-> {\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
            .addStatement("    final $L $L = new $L(sBuilder)", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("    director.accept($L)", internalBuilderVarName)
            .addStatement("})");
            if (isFldMandatory) {
                setBuilderFieldValue.addStatement("$L = true", validatorSubFieldName);
            }
        } else {
            setBuilderFieldValue
            .addStatement("final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("director.accept($L)", internalBuilderVarName)
            .addCode("schemaObjectBuilder.setJsonFieldValue(\n")
            .addCode("  $L.$L,\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
            .beginControlFlow("  jsonBuilder ->")
            .addStatement("  $L.build(jsonBuilder)", internalBuilderVarName)
            .endControlFlow()
            .addStatement(")");
        }

        objectBuilderClassBuilder.addMethod(setBuilderFieldValue.build());
    }

    private static void addBuilderStreamParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFlattened,
        final boolean isFldMandatory,
        final String validatorSubFieldName
    )
    {
        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();
        final MethodSpec.Builder setStreamFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName);

        if (isFlattened) {
            setStreamFieldValue
                .addCode("  schemaObjectBuilder.setFlattenedFieldValue($L.$L,\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
                .addCode("    directors.<Consumer<SchemaObjectBuilder>>map(director -> {\n")
                .addCode("    return sBuilder -> {\n")
                .addStatement("      final $L $L = new $L(sBuilder)", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
                .addStatement("      director.accept($L)", internalBuilderVarName)
                .addStatement("    }")
                .addStatement("}))");
            if (isFldMandatory) {
                setStreamFieldValue.addStatement("$L = true", validatorSubFieldName);
            }
        } else {
            setStreamFieldValue
                .addCode("schemaObjectBuilder.setJsonFieldValue(\n")
                .addCode("  $L.$L,\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
                .addCode("  directors.<Consumer<JsonBuilder>>map(director -> {\n")
                .addStatement("    final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
                .addStatement("    director.accept($L)", internalBuilderVarName)
                .addCode("    return jsonBuilder -> {\n")
                .addStatement("      $L.build(jsonBuilder)", internalBuilderVarName)
                .addStatement("    }")
                .addStatement("}))");
        }
        objectBuilderClassBuilder.addMethod(setStreamFieldValue.build());
    }

    private static void addBuilderListParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(List.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec setListFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName)
            .addStatement("set$L(directors.stream())", fieldFunctionName)
            .build();

        objectBuilderClassBuilder.addMethod(setListFieldValue);
    }

    private static void addNestedObjectBuilderParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String internalVarName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFlattened
    )
    {
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "director")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setBuilderFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName);
        if(isFlattened) {
            setBuilderFieldValue
                .addStatement(
                    "final $L $L = new $L(this.schemaObjectBuilder)",
                    objBuilderClassName, internalBuilderVarName, objBuilderClassName);
        } else {
            setBuilderFieldValue
                .addStatement("final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName);
        }
        setBuilderFieldValue
            .addStatement("director.accept($L)", internalBuilderVarName)
            .addStatement("$L = new ArrayList<>()", internalVarName)
            .addStatement("$L.add($L)", internalVarName, internalBuilderVarName);

        objectBuilderClassBuilder.addMethod(setBuilderFieldValue.build());
    }

    private static void addNestedObjectBuilderStreamParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String internalVarName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFlattened
    )
    {
        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();
        final MethodSpec.Builder setStreamFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName)
            .addCode("$L = directors.map(director -> {\n", internalVarName);
        if (isFlattened) {
            setStreamFieldValue.addStatement(
                "  final $L $L = new $L(this.schemaObjectBuilder)",
                objBuilderClassName, internalBuilderVarName, objBuilderClassName);
        } else {
            setStreamFieldValue.addStatement("  final $L $L = new $L()",
                objBuilderClassName, internalBuilderVarName, objBuilderClassName);
        }
        setStreamFieldValue
            .addStatement("  director.accept($L)", internalBuilderVarName)
            .addStatement("  return $L", internalBuilderVarName)
            .addStatement("}).collect($T.toList())", Collectors.class);

        objectBuilderClassBuilder.addMethod(setStreamFieldValue.build());
    }

    private static void addArrayParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield,
        final String parentFieldName,
        final boolean flattenedParentField,
        final boolean fldIsMandatory,
        final String validatorSubFieldName
    )
    {
        final ParameterSpec arrayParamFieldName = ParameterSpec
            .builder( ArrayTypeName.of(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue)), "values")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setArrayFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(arrayParamFieldName)
            .varargs(true);

        if (isSubfield) {
            if(flattenedParentField) {
                setArrayFieldValue.addStatement(
                    "schemaObjectBuilder.set$LFieldValue($L.$L.$L, values)",
                    PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(),
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName);
                if (fldIsMandatory) {
                    // Note mandatory field has been set
                    setArrayFieldValue.addStatement("$L = true", validatorSubFieldName);
                }
            } else {
                setArrayFieldValue.addStatement("this.$L = $T.asList(values)", subFieldName, Arrays.class);
            }
        } else {
            setArrayFieldValue.addStatement(
                "schemaObjectBuilder.set$LFieldValue($L.$L, values)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), SchemaGeneratorHelper.CLASS_NAME, propertyName);
        }
        objectBuilderClassBuilder.addMethod(setArrayFieldValue.build());
    }

    private static void addListParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield,
        final String parentFieldName,
        final boolean flattenedParentField,
        final boolean fldIsMandatory,
        final String validatorSubFieldName
    )
    {
        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(
                ParameterizedTypeName.get(ClassName.get(List.class), TypeName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue))),
                "values")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setListFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName);

        if (isSubfield) {
            if(flattenedParentField) {
                setListFieldValue.addStatement(
                    "schemaObjectBuilder.set$LFieldValue($L.$L.$L, values)",
                    PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(),
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName);
                if (fldIsMandatory) {
                    // Note mandatory field has been set
                    setListFieldValue.addStatement("$L = true", validatorSubFieldName);
                }
            } else {
                setListFieldValue.addStatement("this.$L = values", subFieldName);
            }
        } else {
            setListFieldValue.addStatement(
                "schemaObjectBuilder.set$LFieldValue($L.$L, values)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), SchemaGeneratorHelper.CLASS_NAME, propertyName);
        }

        objectBuilderClassBuilder.addMethod(setListFieldValue.build());
    }

    private static void addSingleValueAddMethod(
        final Builder objectBuilderClassBuilder,
        final ParameterSpec paramSingleFieldValue,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield,
        final String parentFieldName,
        final boolean flattenedParentField,
        final boolean fldIsMandatory,
        final String validatorSubFieldName
    )
    {
        final MethodSpec.Builder addFieldValue = MethodSpec.methodBuilder("add" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(paramSingleFieldValue);

        if (isSubfield) {
            if(flattenedParentField) {
                addFieldValue.addStatement(
                    "schemaObjectBuilder.add$LFieldValue($L.$L.$L, value)",
                    PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(),
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName);
                if (fldIsMandatory) {
                    // Note mandatory field has been set
                    addFieldValue.addStatement("$L = true", validatorSubFieldName);
                }
            } else {
                addFieldValue.beginControlFlow("if ($L == null)", subFieldName);
                addFieldValue.addStatement(
                    "this.$L = new $T()",
                    subFieldName,
                    ParameterizedTypeName.get(ClassName.get(ArrayList.class), TypeName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue))));
                addFieldValue.endControlFlow();
                addFieldValue.addStatement("this.$L.add(value)", subFieldName);
            }
        } else {
            addFieldValue.addStatement(
                "schemaObjectBuilder.add$LFieldValue($L.$L, value)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), SchemaGeneratorHelper.CLASS_NAME, propertyName);
        }

        objectBuilderClassBuilder.addMethod(addFieldValue.build());
    }

}
