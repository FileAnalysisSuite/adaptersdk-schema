/*
 * Copyright 2022-2023 Open Text.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.fileanalysissuite.adaptersdk.schema.generator;

import com.fasterxml.jackson.databind.JsonNode;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeSpec.Builder;
import io.github.fileanalysissuite.adaptersdk.schema.builders.JsonBuilder;
import io.github.fileanalysissuite.adaptersdk.schema.builders.SchemaObjectBuilder;
import java.io.IOException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import org.codehaus.plexus.util.StringUtils;

final class SchemaObjectBuilderGenerator
{
    private static final String BUILDER_CLASS_NAME = "AdapterSdkSchemaObjectBuilder";

    private static final Map<String, Class> PROPERTY_TYPES_LOOKUP = new HashMap<String, Class>()
    {
        {
            put("STRING", String.class);
            put("FULLTEXT", String.class);
            put("LONG", Long.class);
            put("DOUBLE", Double.class);
            put("INTEGER", Integer.class);
            put("BOOLEAN", Boolean.class);
            put("DATETIME", Instant.class);
        }
    };

    private static final Map<String, Class> PROPERTY_PRIMITIVE_TYPES_LOOKUP = new HashMap<String, Class>()
    {
        {
            put("LONG", long.class);
            put("DOUBLE", double.class);
            put("INTEGER", int.class);
            put("BOOLEAN", boolean.class);
        }
    };

    private final Filer filer;
    private final JsonNode schemaNode;
    private final JsonNode typesNode;

    public SchemaObjectBuilderGenerator(final Filer filer, final JsonNode schemaNode)
    {
        this.filer = filer;
        this.schemaNode = schemaNode;
        this.typesNode = schemaNode.get("types");
    }

    public boolean process()
    {
        final TypeSpec.Builder schemaClassBuilder
            = createSchemaObjectBuilderClass(
                BUILDER_CLASS_NAME, false, null, null, schemaNode.get("fields"), new String[0], new String(), true, false);

        final JavaFile javaFile = JavaFile.builder(SchemaGeneratorHelper.PACKAGE_NAME, schemaClassBuilder.build())
            .addFileComment("\nThis file is auto-generated by SchemaGenerator\n").build();

        try {
            javaFile.writeTo(filer);
        } catch (final IOException e) {
            throw new RuntimeException("Unable to write out generated schema builder file", e);
        }
        return false;
    }

    private TypeSpec.Builder createSchemaObjectBuilderClass(
        final String builderClassName,
        final boolean isEntityTypeObjectBuilderClass,
        final MethodSpec.Builder buildFunctionBuilder,
        MethodSpec.Builder validateFunctionBuilder,
        final JsonNode schemaNode,
        final String[] path,
        final String parentFieldName,
        final boolean isParentFieldFlattened,
        final boolean isStatic
    )
    {
        final Modifier[] modifiers = isStatic
            ? new Modifier[]{Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL}
            : new Modifier[]{Modifier.PUBLIC, Modifier.FINAL};
        final TypeSpec.Builder schemaClassBuilder = TypeSpec.classBuilder(builderClassName)
            .addModifiers(modifiers);

        addSchemaObjectBuilderFieldAndCtor(schemaClassBuilder, isStatic);

        // Create a 'validate' method
        final MethodSpec.Builder parentValidator = validateFunctionBuilder;

        validateFunctionBuilder = MethodSpec.methodBuilder("validate")
            .addModifiers(isEntityTypeObjectBuilderClass ? Modifier.PRIVATE : Modifier.PUBLIC);

        addPropertySetters(
            schemaClassBuilder,
            isEntityTypeObjectBuilderClass,
            buildFunctionBuilder,
            validateFunctionBuilder,
            schemaNode,
            path,
            parentFieldName,
            isParentFieldFlattened
        );

        schemaClassBuilder.addMethod(validateFunctionBuilder.build());

        if (parentValidator != null) {
            validateFunctionBuilder = parentValidator;
        }

        return schemaClassBuilder;
    }

    private static void addSchemaObjectBuilderFieldAndCtor(
        final TypeSpec.Builder schemaClassBuilder,
        final boolean isStaticClass
    )
    {
        final FieldSpec field = FieldSpec
            .builder(SchemaObjectBuilder.class, "schemaObjectBuilder")
            .addModifiers(Modifier.PRIVATE, Modifier.FINAL)
            .build();

        schemaClassBuilder.addField(field);

        final Modifier ctorModifier = isStaticClass
            ? Modifier.PRIVATE
            : Modifier.PUBLIC;
        final MethodSpec constructor = MethodSpec
            .constructorBuilder()
            .addModifiers(ctorModifier)
            .addParameter(SchemaObjectBuilder.class, "schemaObjectBuilder", Modifier.FINAL)
            .addStatement("this.schemaObjectBuilder = schemaObjectBuilder")
            .build();

        schemaClassBuilder.addMethod(constructor);
    }

    private void addPropertySetters(
        final TypeSpec.Builder objectBuilderClassBuilder,
        final boolean isEntityTypeObjectBuilderClass,
        MethodSpec.Builder buildFunctionBuilder,
        MethodSpec.Builder validateFunctionBuilder,
        final JsonNode entityDef,
        final String[] path,
        final String parentFieldName,
        final boolean isParentFieldFlattened
    )
    {
        /*
            flattened + json + flattened ====> not possible
            flattened + flattened
            flattened + json
            flattened + flattened + flattened + flattened + json
            json + json + json - starts with json, all nested entities have to be json
         */
        final Iterator<Entry<String, JsonNode>> propertyIterator = entityDef.fields();

        final boolean isSubfield = path.length > 0;

        while (propertyIterator.hasNext()) {
            final Entry<String, JsonNode> property = propertyIterator.next();
            final JsonNode fieldAttributes = property.getValue();

            final String propertyName = property.getKey();

            final String fieldType = fieldAttributes.get("type").textValue();

            final int endOfTypeDimension = fieldType.lastIndexOf('[');

            final String fieldTypeValue = endOfTypeDimension > 0 ? fieldType.substring(0, endOfTypeDimension) : fieldType;

            final int numberOfDimensions = endOfTypeDimension > 0 ? StringUtils.countMatches(fieldType, "[]") : 0;

            final boolean isFlattened
                = fieldAttributes.hasNonNull("objectEncoding")
                ? fieldAttributes.get("objectEncoding").textValue().equals("flattened")
                : false;

            final boolean isFieldMultiValued = fieldType.endsWith("[]");

            final boolean isFieldMandatory
                = fieldAttributes.hasNonNull("mandatory")
                ? fieldAttributes.get("mandatory").booleanValue()
                : false;

            final String fieldFunctionName = SchemaGeneratorHelper.toProperCase(propertyName);

            if (isFieldMandatory && !isEntityTypeObjectBuilderClass) {
                // This is a mandatory field of the main Schema
                // Add instance variable for checking if field is set
                final String validatorFieldName = SchemaGeneratorHelper.toValidatorFieldName(propertyName);
                addValidateField(objectBuilderClassBuilder, validatorFieldName);

                // Update validate function
                checkFieldsInValidateMethod(validateFunctionBuilder, null, propertyName, validatorFieldName);
            }

            if (!SchemaGeneratorHelper.PROPERTY_TYPES.contains(fieldType)) {
                // Entity/Object type field
                addEntityTypePropertySetters(
                    objectBuilderClassBuilder,
                    isEntityTypeObjectBuilderClass,
                    buildFunctionBuilder,
                    validateFunctionBuilder,
                    fieldFunctionName,
                    fieldType,
                    fieldTypeValue,
                    isFieldMandatory,
                    isFieldMultiValued,
                    numberOfDimensions,
                    isSubfield,
                    path,
                    propertyName,
                    parentFieldName,
                    isFlattened,
                    isParentFieldFlattened
                );
            } else {
                // non entity type field
                addNonEntityTypePropertySetterMethods(
                    objectBuilderClassBuilder,
                    buildFunctionBuilder,
                    validateFunctionBuilder,
                    fieldFunctionName,
                    fieldTypeValue,
                    isFieldMandatory,
                    isFieldMultiValued,
                    isSubfield,
                    propertyName,
                    parentFieldName,
                    isParentFieldFlattened
                );
            }
        }
    }

    private void addEntityTypePropertySetters(
        final TypeSpec.Builder objectBuilderClassBuilder,
        final boolean isEntityTypeObjectBuilderClass,
        MethodSpec.Builder buildFunctionBuilder,
        MethodSpec.Builder validateFunctionBuilder,
        final String fieldFunctionName,
        final String fieldType,
        final String fieldTypeValue,
        final boolean isFieldMandatory,
        final boolean isFieldMultiValued,
        final int numberOfDimensions,
        final boolean isSubfield,
        final String[] path,
        final String propertyName,
        final String parentFieldName,
        final boolean isFlattened,
        final boolean isParentFieldFlattened
    )
    {
        final String objBuilderClassName = fieldFunctionName + "ObjectBuilder";
        final int endOfTypeName = fieldType.indexOf('[');
        final String refTypeName = endOfTypeName > 0 ? fieldType.substring(0, endOfTypeName) : fieldType;
        final JsonNode subentityDef = typesNode.get(refTypeName);

        final String[] newPath = SchemaGeneratorHelper.addExtraElement(path, objBuilderClassName);
        final String fullName = isSubfield ? parentFieldName + "." + propertyName : propertyName;

        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final String internalVarName = SchemaGeneratorHelper.toFieldNameCase(propertyName);
        final String internalBuilderVarName = internalVarName + "Builder";

        // Add clear field method body
        final MethodSpec.Builder clearFieldMethodBuilder = MethodSpec.methodBuilder("clear" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC);

        // Add setters, clear, and list object builder classes
        // "ocr[][]" // every additional dimension would need a ListBuilder
        final String validatorSubFieldName = SchemaGeneratorHelper.toValidatorFieldName(internalBuilderVarName);
        if (numberOfDimensions > 1) {
            addMultiDimensionalEntityTypeProperty(
                objectBuilderClassBuilder,
                isEntityTypeObjectBuilderClass,
                objBuilderClassName,
                internalBuilderVarName,
                fieldFunctionName,
                fullName,
                internalVarName,
                numberOfDimensions,
                isFlattened,
                isFieldMandatory,
                isSubfield,
                validatorSubFieldName
            );
            // Add 'clear' field method body
            clearFieldMethodBuilder
                .addStatement("schemaObjectBuilder.clearField($L.$L)", SchemaGeneratorHelper.CLASS_NAME, fullName);
        } else {
            // Single dimension field
            if (isFlattened) {
                // Sub entity is flattened
                // Add entity type field 'set' function with 'Builder' param
                addBuilderParamSetterMethod(
                    objectBuilderClassBuilder,
                    isEntityTypeObjectBuilderClass,
                    fieldFunctionName,
                    fullName,
                    builderTypeName,
                    objBuilderClassName,
                    internalBuilderVarName,
                    isFlattened,
                    isFieldMandatory,
                    isSubfield,
                    validatorSubFieldName);

                // Add entity type field 'set' function with 'Stream' param
                addBuilderStreamParamSetterMethod(
                    objectBuilderClassBuilder,
                    isEntityTypeObjectBuilderClass,
                    fieldFunctionName,
                    fullName,
                    builderTypeName,
                    objBuilderClassName,
                    internalBuilderVarName,
                    isFlattened,
                    isFieldMandatory,
                    isSubfield,
                    validatorSubFieldName);

                // Add 'set' function with 'List' param
                addBuilderListParamSetterMethod(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    builderTypeName);

                // Add 'clear' field method body
                clearFieldMethodBuilder
                    .addStatement("schemaObjectBuilder.clearField($L.$L)", SchemaGeneratorHelper.CLASS_NAME, fullName);

                if (isFieldMandatory && isSubfield) {
                    // Add instance variable for checking if subField is set
                    addValidateField(objectBuilderClassBuilder, validatorSubFieldName);

                    // Note that mandatory field is cleared
                    markPropertyIsCleared(clearFieldMethodBuilder, validatorSubFieldName);

                    // add field to validate method
                    checkFieldsInValidateMethod(
                        validateFunctionBuilder,
                        parentFieldName,
                        propertyName,
                        validatorSubFieldName);
                }

            } else {
                // Sub entity is json encoded
                if (isParentFieldFlattened) {
                    // parent is flattened, but this sub entity is not
                    buildFunctionBuilder = MethodSpec.methodBuilder("build")
                        .addModifiers(Modifier.PRIVATE)
                        .addParameter(ParameterSpec.builder(JsonBuilder.class, "jsonBuilder").addModifiers(Modifier.FINAL).build())
                        .addStatement("jsonBuilder.writeStartObject()");
                    // Add entity type property 'set' function 'Builder' param
                    addBuilderParamSetterMethod(
                        objectBuilderClassBuilder,
                        isEntityTypeObjectBuilderClass,
                        fieldFunctionName,
                        fullName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName,
                        isFlattened,
                        isFieldMandatory,
                        isSubfield,
                        validatorSubFieldName);

                    // Add entity type property 'set' function with 'Stream' param
                    addBuilderStreamParamSetterMethod(
                        objectBuilderClassBuilder,
                        isEntityTypeObjectBuilderClass,
                        fieldFunctionName,
                        fullName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName,
                        isFlattened,
                        isFieldMandatory,
                        isSubfield,
                        validatorSubFieldName);

                    // Add 'clear' field method body
                    clearFieldMethodBuilder
                        .addStatement("schemaObjectBuilder.clearField($L.$L)", SchemaGeneratorHelper.CLASS_NAME, fullName);
                } else {
                    // parent is json encoded, this sub entity is also json encoded
                    final FieldSpec entityTypeField = FieldSpec
                        .builder(
                            isFieldMultiValued
                                ? ParameterizedTypeName.get(
                                    ClassName.get(List.class), ClassName.get("", objBuilderClassName))
                                : ClassName.get("", objBuilderClassName),
                            internalVarName)
                        .addModifiers(new Modifier[]{Modifier.PRIVATE})
                        .build();
                    objectBuilderClassBuilder.addField(entityTypeField);

                    // Add entity type property 'set' function 'Builder' param
                    addNestedObjectBuilderParamSetterMethod(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        internalVarName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName,
                        isFlattened);

                    // Add entity type property 'set' function with 'Stream' param
                    addNestedObjectBuilderStreamParamSetterMethod(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        internalVarName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName,
                        isFlattened);

                    // Add 'clear' field method body
                    clearFieldMethodBuilder.addStatement("$L = null", internalVarName);
                }

                // Write Json field
                writeJsonFieldsInBuildMethod(
                    buildFunctionBuilder,
                    fieldTypeValue,
                    isFieldMandatory,
                    isFieldMultiValued,
                    parentFieldName,
                    propertyName,
                    internalVarName,
                    objBuilderClassName);

                // Add set function with List param
                addBuilderListParamSetterMethod(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    builderTypeName);
            }
        }

        // Add an object builder class for entity type property (recursively creates SchemaObjectBuilder)
        addEntityTypeObjectBuilderClass(
            objectBuilderClassBuilder,
            objBuilderClassName,
            buildFunctionBuilder,
            validateFunctionBuilder,
            subentityDef,
            newPath,
            fullName,
            isFlattened);

        if (isFieldMandatory && !isEntityTypeObjectBuilderClass) {
            // Note that mandatory entity-type field of main schema is cleared
            markPropertyIsCleared(clearFieldMethodBuilder, SchemaGeneratorHelper.toValidatorFieldName(propertyName));
        }
        // Add clear field method
        objectBuilderClassBuilder.addMethod(clearFieldMethodBuilder.build());
    }

    private static void markPropertyIsSet(final MethodSpec.Builder setFieldMethodBuilder, final String validatorFieldName)
    {
        setFieldMethodBuilder.addStatement("$L = true", validatorFieldName);
    }

    private static void markPropertyIsCleared(final MethodSpec.Builder clearFieldMethodBuilder, final String validatorFieldName)
    {
        clearFieldMethodBuilder.addStatement("$L = false", validatorFieldName);
    }

    private static void addValidateField(final TypeSpec.Builder objectBuilderClassBuilder, final String fieldNameCheck)
    {
        final FieldSpec validateField = FieldSpec
            .builder(
                TypeName.BOOLEAN,
                fieldNameCheck)
            .addModifiers(new Modifier[]{Modifier.PRIVATE})
            .build();
        objectBuilderClassBuilder.addField(validateField);
    }

    private static void addMultiDimensionalEntityTypeProperty(
        final TypeSpec.Builder objectBuilderClassBuilder,
        final boolean isEntityTypeObjectBuilderClass,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final String fieldFunctionName,
        final String fullName,
        final String internalVarName,
        final int numberOfDimensions,
        final boolean isFlattened,
        final boolean isFieldMandatory,
        final boolean isSubField,
        final String validatorSubFieldName
    )
    {
        // Multi-dimensional field
        // Add a list object builder class for property
        final String suffix = "ObjectBuilder";
        String listName = "";
        for (int i = 0; i < numberOfDimensions - 1; i++) {
            listName += "List";
            addListBuilderClass(
                objectBuilderClassBuilder,
                objBuilderClassName,
                fieldFunctionName + listName + suffix,
                internalVarName,
                isFlattened);
        }
        final String listObjBuilderClassName = fieldFunctionName + listName + suffix;
        final ParameterizedTypeName listBuilderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", listObjBuilderClassName));

        // Add 'set' function with 'Builder' param
        addBuilderParamSetterMethod(
            objectBuilderClassBuilder,
            isEntityTypeObjectBuilderClass,
            fieldFunctionName,
            fullName,
            listBuilderTypeName,
            listObjBuilderClassName,
            internalBuilderVarName,
            isFlattened,
            isFieldMandatory,
            isSubField,
            validatorSubFieldName);

        // Add 'set' function with 'Stream' param
        addBuilderStreamParamSetterMethod(
            objectBuilderClassBuilder,
            isEntityTypeObjectBuilderClass,
            fieldFunctionName,
            fullName,
            listBuilderTypeName,
            listObjBuilderClassName,
            internalBuilderVarName,
            isFlattened,
            isFieldMandatory,
            isSubField,
            validatorSubFieldName);

        // Add 'set' function with 'List' param
        addBuilderListParamSetterMethod(
            objectBuilderClassBuilder,
            fieldFunctionName,
            listBuilderTypeName);
    }

    private void addEntityTypeObjectBuilderClass(
        final TypeSpec.Builder objectBuilderClassBuilder,
        final String objBuilderClassName,
        MethodSpec.Builder buildFunctionBuilder,
        MethodSpec.Builder validateFunctionBuilder,
        final JsonNode subentityDef,
        final String[] newPath,
        final String fullName,
        final boolean isFlattened
    )
    {
        if (isFlattened) {
            final TypeSpec.Builder fieldObjectBuilderClassBuilder
                = createSchemaObjectBuilderClass(
                    objBuilderClassName,
                    true,
                    buildFunctionBuilder,
                    validateFunctionBuilder,
                    subentityDef,
                    newPath,
                    fullName,
                    true,
                    true);

            objectBuilderClassBuilder.addType(fieldObjectBuilderClassBuilder.build());
        } else {
            // This class will have instance variables for each property and a 'build' function to write json values
            final TypeSpec.Builder fieldObjectBuilderClassBuilder = TypeSpec.classBuilder(objBuilderClassName)
                .addModifiers(new Modifier[]{Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL})
                .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE)
                    .build());

            // Create a 'build' method
            final MethodSpec.Builder parentBuilder = buildFunctionBuilder;
            buildFunctionBuilder = MethodSpec.methodBuilder("build")
                .addModifiers(Modifier.PRIVATE)
                .addParameter(ParameterSpec.builder(JsonBuilder.class, "jsonBuilder").addModifiers(Modifier.FINAL).build())
                .addStatement("jsonBuilder.writeStartObject()");

            // Add all the sub-fields of this entity type property
            addPropertySetters(
                fieldObjectBuilderClassBuilder,
                true,
                buildFunctionBuilder,
                validateFunctionBuilder,
                subentityDef,
                newPath,
                fullName,
                false);

            buildFunctionBuilder.addStatement("jsonBuilder.writeEndObject()");
            fieldObjectBuilderClassBuilder.addMethod(buildFunctionBuilder.build());
            if (parentBuilder != null) {
                buildFunctionBuilder = parentBuilder;
            }
            objectBuilderClassBuilder.addType(fieldObjectBuilderClassBuilder.build());
        }
    }

    private static void addListBuilderClass(
        final TypeSpec.Builder objectBuilderClassBuilder,
        final String objBuilderClassName,
        final String listObjBuilderClassName,
        final String internalVarName,
        final boolean isFlattened
    )
    {
        final TypeSpec.Builder fieldListObjectBuilderClassBuiler = TypeSpec.classBuilder(listObjBuilderClassName)
            .addModifiers(new Modifier[]{Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL});
        // flattened does not need 'build' function and instance/state variables
        if (isFlattened) {
            addSchemaObjectBuilderFieldAndCtor(fieldListObjectBuilderClassBuiler, true);

            // Add 'set' function with 'Builder' param
            addFieldListObjectBuilderBuilderParamSetterMethod(
                fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName);

            // Add 'set' function with 'Stream' param
            addFieldListObjectBuilderStreamParamSetterMethod(
                fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName);

            // Add 'set' function with 'List' param
            addFieldListObjectBuilderListParamSetterMethod(fieldListObjectBuilderClassBuiler, objBuilderClassName);

            // Add 'clear' field method
            addFieldListObjectBuilderClearMethod(fieldListObjectBuilderClassBuiler);

            // Add 'validate' field method
            addFieldListObjectBuilderValidateMethod(fieldListObjectBuilderClassBuiler);
        } else {
            // Json encoded
            fieldListObjectBuilderClassBuiler.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build());

            // Add instance variable for list of field object builders
            final String listName = internalVarName + "Builders";
            final FieldSpec fieldObjBuilderList = FieldSpec
                .builder(ParameterizedTypeName.get(
                    ClassName.get(List.class), ClassName.get("", objBuilderClassName)), listName)
                .addModifiers(new Modifier[]{Modifier.PRIVATE})
                .build();
            fieldListObjectBuilderClassBuiler.addField(fieldObjBuilderList);

            // Add 'set' function with 'Builder' param
            addFieldListObjectBuilderBuilderParamSetter(
                fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName, listName);

            // Add 'set' function with 'Stream' param
            addFieldListObjectBuilderStreamParamSetter(
                fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName, listName);

            // Add 'set' function with 'List' param
            addFieldListObjectBuilderListParamSetterMethod(fieldListObjectBuilderClassBuiler, objBuilderClassName);

            // Add 'clear' field method
            addFieldListObjectBuilderClearMethod(fieldListObjectBuilderClassBuiler, listName);

            // Add 'build' method
            addFieldListObjectBuilderBuildMethod(fieldListObjectBuilderClassBuiler, objBuilderClassName, listName);
        }

        objectBuilderClassBuilder.addType(fieldListObjectBuilderClassBuiler.build());
    }

    private static void addNonEntityTypePropertySetterMethods(
        final TypeSpec.Builder objectBuilderClassBuilder,
        final MethodSpec.Builder buildFunctionBuilder,
        final MethodSpec.Builder validateFunctionBuilder,
        final String fieldFunctionName,
        final String fieldTypeValue,
        final boolean isFieldMandatory,
        final boolean isFieldMultiValued,
        final boolean isSubfield,
        final String propertyName,
        final String parentFieldName,
        final boolean isParentFieldFlattened
    )
    {
        final Class<?> boxedFieldType = PROPERTY_TYPES_LOOKUP.get(fieldTypeValue);
        final Class<?> fieldType = TypeName.get(boxedFieldType).isBoxedPrimitive()
            ? PROPERTY_PRIMITIVE_TYPES_LOOKUP.get(fieldTypeValue)
            : boxedFieldType;
        final String methodNameForType = boxedFieldType.getSimpleName();

        final ParameterSpec paramSingleFieldValue = ParameterSpec
            .builder(fieldType, "value")
            .addModifiers(Modifier.FINAL)
            .build();

        final String subFieldName = SchemaGeneratorHelper.toFieldNameCase(propertyName);
        final String validatorSubFieldName = SchemaGeneratorHelper.toValidatorFieldName(propertyName);

        // Add setter variations for multi-valued field
        if (isFieldMultiValued) {
            // Set 'array' value
            addArrayParamSetterMethod(
                objectBuilderClassBuilder,
                fieldFunctionName,
                propertyName,
                subFieldName,
                fieldTypeValue,
                isSubfield,
                parentFieldName,
                isParentFieldFlattened,
                isFieldMandatory,
                validatorSubFieldName);

            // Set 'List' value
            addListParamSetterMethod(
                objectBuilderClassBuilder,
                fieldFunctionName,
                propertyName,
                subFieldName,
                fieldTypeValue,
                isSubfield,
                parentFieldName,
                isParentFieldFlattened,
                isFieldMandatory,
                validatorSubFieldName);

            // Add 'single' value
            addSingleValueAddMethod(
                objectBuilderClassBuilder,
                paramSingleFieldValue,
                fieldFunctionName,
                propertyName,
                subFieldName,
                fieldTypeValue,
                isSubfield,
                parentFieldName,
                isParentFieldFlattened,
                isFieldMandatory,
                validatorSubFieldName);
        }

        final MethodSpec.Builder setSingleFieldValueMethodBuilder = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(paramSingleFieldValue);

        final MethodSpec.Builder clearFieldMethodBuilder = MethodSpec.methodBuilder("clear" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC);

        if (isSubfield) {
            // This is a non entity type property of an entity type property
            if (isParentFieldFlattened) {
                clearFieldMethodBuilder
                    .addStatement(
                        "schemaObjectBuilder.clearField($L.$L)",
                        SchemaGeneratorHelper.CLASS_NAME, parentFieldName + "." + propertyName);

                setSingleFieldValueMethodBuilder.addStatement(
                    "schemaObjectBuilder.set$LFieldValue($L.$L, value)",
                    methodNameForType,
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName + "." + propertyName);

                if (isFieldMandatory) {
                    // Add instance variable for checking if subField is set
                    addValidateField(objectBuilderClassBuilder, validatorSubFieldName);

                    // Note that mandatory field is set
                    markPropertyIsSet(setSingleFieldValueMethodBuilder, validatorSubFieldName);
                    // Note that mandatory field is cleared
                    markPropertyIsCleared(clearFieldMethodBuilder, validatorSubFieldName);

                    // add field to validate method
                    checkFieldsInValidateMethod(
                        validateFunctionBuilder,
                        parentFieldName,
                        propertyName,
                        validatorSubFieldName);
                }
            } else {
                // Add instance variable for subField
                final FieldSpec field = FieldSpec
                    .builder(
                        isFieldMultiValued
                            ? ParameterizedTypeName.get(
                                ClassName.get(List.class), ClassName.get(fieldType))
                            : ClassName.get(boxedFieldType),
                        subFieldName)
                    .addModifiers(new Modifier[]{Modifier.PRIVATE})
                    .build();
                objectBuilderClassBuilder.addField(field);

                // Add 'clear' function body
                clearFieldMethodBuilder.addStatement(subFieldName + " = null");

                // write Json fields
                writeJsonFieldsInBuildMethod(
                    buildFunctionBuilder,
                    fieldTypeValue,
                    isFieldMandatory,
                    isFieldMultiValued,
                    parentFieldName,
                    propertyName,
                    subFieldName,
                    null);

                // Add setters for multi-valued subfield
                if (isFieldMultiValued) {
                    // Add set single value function body
                    setSingleFieldValueMethodBuilder.addStatement(
                        "this.$L = new $T()",
                        subFieldName,
                        ParameterizedTypeName
                            .get(ClassName.get(ArrayList.class), TypeName.get(fieldType)));
                    setSingleFieldValueMethodBuilder.addStatement("this.$L.add(value)", subFieldName);
                } else {
                    setSingleFieldValueMethodBuilder.addStatement("this.$L = value", subFieldName);
                }
            }
        } else {
            // This is a non entity type property in the main schema
            clearFieldMethodBuilder
                .addStatement("schemaObjectBuilder.clearField($L.$L)", SchemaGeneratorHelper.CLASS_NAME, propertyName);

            setSingleFieldValueMethodBuilder.addStatement(
                "schemaObjectBuilder.set$LFieldValue($L.$L, value)",
                methodNameForType, SchemaGeneratorHelper.CLASS_NAME, propertyName);

            if (isFieldMandatory) {
                final String validatorFieldName = SchemaGeneratorHelper.toValidatorFieldName(propertyName);
                markPropertyIsCleared(clearFieldMethodBuilder, validatorFieldName);
                markPropertyIsSet(setSingleFieldValueMethodBuilder, validatorFieldName);
            }
        }
        // Add 'single value' setter method
        objectBuilderClassBuilder.addMethod(setSingleFieldValueMethodBuilder.build());

        // Add 'clear' field method
        objectBuilderClassBuilder.addMethod(clearFieldMethodBuilder.build());
    }

    private static void addFieldListObjectBuilderBuilderParamSetter(
        final Builder listObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName,
        final String listName
    )
    {
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "director")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec.Builder setBuilderFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName);

        setBuilderFieldValue
            .addStatement("final $L $L = new $L()", objBuilderClassName, varName, objBuilderClassName)
            .addStatement("director.accept($L)", varName)
            .addStatement("$L = new ArrayList<>()", listName)
            .addStatement("$L.add($L)", listName, varName);

        listObjectBuilderClassBuiler.addMethod(setBuilderFieldValue.build());
    }

    private static void addFieldListObjectBuilderBuilderParamSetterMethod(
        final Builder listObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName
    )
    {
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "director")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec.Builder setBuilderFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName);

        setBuilderFieldValue
            .addCode("this.schemaObjectBuilder.setFlattenedFieldValue(null, builder -> {\n")
            .addStatement("    final $L $L = new $L(builder)", objBuilderClassName, varName, objBuilderClassName)
            .addStatement("    director.accept($L)", varName)
            .addStatement("    $L.validate()", varName)
            .addStatement("})");

        listObjectBuilderClassBuiler.addMethod(setBuilderFieldValue.build());
    }

    private static void addFieldListObjectBuilderStreamParamSetter(
        final Builder listObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName,
        final String listName
    )
    {
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec.Builder setStreamFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName);

        setStreamFieldValue
            .addCode("$L = directors.map(director -> {\n", listName)
            .addStatement("  final $L $L = new $L()", objBuilderClassName, varName, objBuilderClassName)
            .addStatement("  director.accept($L)", varName)
            .addStatement("  return $L", varName)
            .addStatement("}).collect($T.toList())", Collectors.class);

        listObjectBuilderClassBuiler.addMethod(setStreamFieldValue.build());
    }

    private static void addFieldListObjectBuilderStreamParamSetterMethod(
        final Builder listObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName
    )
    {
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec.Builder setStreamFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName);

        setStreamFieldValue
            .addCode("this.schemaObjectBuilder.setFlattenedFieldValue(null, directors.map(director -> builder -> {\n")
            .addStatement("    final $L $L = new $L(builder)", objBuilderClassName, varName, objBuilderClassName)
            .addStatement("    director.accept($L)", varName)
            .addStatement("    $L.validate()", varName)
            .addStatement("}))");

        listObjectBuilderClassBuiler.addMethod(setStreamFieldValue.build());
    }

    private static void addFieldListObjectBuilderListParamSetterMethod(
        final Builder listObjectBuilderClassBuiler,
        final String objBuilderClassName
    )
    {
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(List.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec setListFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName)
            .addStatement("set(directors.stream())")
            .build();

        listObjectBuilderClassBuiler.addMethod(setListFieldValue);
    }

    private static void addFieldListObjectBuilderClearMethod(
        final Builder listObjectBuilderClassBuiler,
        final String listName
    )
    {
        final MethodSpec clearListMethod = MethodSpec.methodBuilder("clear")
            .addModifiers(Modifier.PUBLIC)
            .addStatement("$L = null", listName)
            .build();

        listObjectBuilderClassBuiler.addMethod(clearListMethod);
    }

    private static void addFieldListObjectBuilderClearMethod(
        final Builder listObjectBuilderClassBuiler
    )
    {
        final MethodSpec clearFieldMethod = MethodSpec.methodBuilder("clear")
            .addModifiers(Modifier.PUBLIC)
            .addStatement("this.schemaObjectBuilder.clearField(null)")
            .build();

        listObjectBuilderClassBuiler.addMethod(clearFieldMethod);
    }

    private static void addFieldListObjectBuilderValidateMethod(
        final Builder listObjectBuilderClassBuiler
    )
    {
        final MethodSpec validateMethod = MethodSpec.methodBuilder("validate")
            .addModifiers(Modifier.PRIVATE)
            .build();

        listObjectBuilderClassBuiler.addMethod(validateMethod);
    }

    private static void addFieldListObjectBuilderBuildMethod(
        final Builder listObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String listName
    )
    {
        final MethodSpec buildFunctionBuilder = MethodSpec.methodBuilder("build")
            .addModifiers(Modifier.PRIVATE)
            .addParameter(ParameterSpec.builder(JsonBuilder.class, "jsonBuilder")
                .addModifiers(Modifier.FINAL).build())
            .addStatement("jsonBuilder.writeStartArray()")
            .beginControlFlow("if ($L != null)", listName)
            .beginControlFlow("for (final $L value : $L)", objBuilderClassName, listName)
            .addStatement("value.build(jsonBuilder)")
            .endControlFlow()
            .endControlFlow()
            .addStatement("jsonBuilder.writeEndArray()")
            .build();

        listObjectBuilderClassBuiler.addMethod(buildFunctionBuilder);
    }

    private static void checkFieldsInValidateMethod(
        final MethodSpec.Builder validateFunctionBuilder,
        final String parentFieldName,
        final String propertyName,
        final String validatorSubFieldName
    )
    {
        validateFunctionBuilder
            .beginControlFlow("if (!$L)", validatorSubFieldName);
        if (parentFieldName == null) {
            validateFunctionBuilder
                .addStatement(
                    "throw new IllegalArgumentException(\"Mandatory field '$L.$L' is not set\")",
                    SchemaGeneratorHelper.CLASS_NAME,
                    propertyName);
        } else {
            validateFunctionBuilder
                .addStatement(
                    "throw new IllegalArgumentException(\"Mandatory field '$L.$L.$L' is not set\")",
                    SchemaGeneratorHelper.CLASS_NAME,
                    parentFieldName,
                    propertyName);
        }
        validateFunctionBuilder.endControlFlow();
    }

    private static void writeJsonFieldsInBuildMethod(
        final MethodSpec.Builder buildFunctionBuilder,
        final String fieldTypeValue,
        final boolean isFieldMandatory,
        final boolean isFieldMultiValued,
        final String parentFieldName,
        final String propertyName,
        final String subFieldName,
        final String objBuilderClassName)
    {
        final Class<?> fieldType = PROPERTY_TYPES_LOOKUP.get(fieldTypeValue);
        if (isFieldMandatory) {
            buildFunctionBuilder
                .beginControlFlow("if ($L == null)", subFieldName)
                .addStatement(
                    "throw new IllegalArgumentException(\"Mandatory field '$L.$L.$L' is not set\")",
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName)
                .nextControlFlow("else");
        } else {
            buildFunctionBuilder.beginControlFlow("if ($L != null)", subFieldName);
        }
        buildFunctionBuilder.addStatement(
            "jsonBuilder.writeFieldName($L.$L.$L.getFieldName())", SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName);

        if (isFieldMultiValued) {
            // Add 'build' function body
            buildFunctionBuilder.addStatement("jsonBuilder.writeStartArray()");

            if (objBuilderClassName == null) {
                buildFunctionBuilder.beginControlFlow(
                    "for(final $L value : $L)", fieldType.getSimpleName(), subFieldName);
                buildFunctionBuilder.addStatement(
                    "jsonBuilder.write$L(value)", fieldType.getSimpleName());
            } else {
                buildFunctionBuilder.beginControlFlow("for(final $L value : $L)", objBuilderClassName, subFieldName);
                buildFunctionBuilder.addStatement("value.build(jsonBuilder)");
            }
            buildFunctionBuilder.endControlFlow();

            buildFunctionBuilder.addStatement("jsonBuilder.writeEndArray()");
        } else {
            buildFunctionBuilder.addStatement(
                "jsonBuilder.write$L($L)", fieldType.getSimpleName(), subFieldName);
        }
        buildFunctionBuilder.endControlFlow();
    }

    private static void addBuilderParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final boolean isEntityTypeObjectBuilderClass,
        final String fieldFunctionName,
        final String propertyName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFlattened,
        final boolean isFieldMandatory,
        final boolean isSubField,
        final String validatorSubFieldName
    )
    {
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "director")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setBuilderFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName);
        if (isFlattened) {
            setFlattenedFieldValue(
                setBuilderFieldValue,
                propertyName,
                objBuilderClassName,
                internalBuilderVarName,
                isFieldMandatory,
                isSubField,
                validatorSubFieldName);
        } else {
            setJsonFieldValue(setBuilderFieldValue, propertyName, objBuilderClassName, internalBuilderVarName);
        }
        if (isFieldMandatory && !isEntityTypeObjectBuilderClass) {
            markPropertyIsSet(setBuilderFieldValue, SchemaGeneratorHelper.toValidatorFieldName(propertyName));
        }
        objectBuilderClassBuilder.addMethod(setBuilderFieldValue.build());
    }

    private static void addBuilderStreamParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final boolean isEntityTypeObjectBuilderClass,
        final String fieldFunctionName,
        final String propertyName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFlattened,
        final boolean isFieldMandatory,
        final boolean isSubField,
        final String validatorSubFieldName
    )
    {
        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();
        final MethodSpec.Builder setStreamFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName);

        if (isFlattened) {
            setFlattenedFieldValueStream(
                setStreamFieldValue,
                propertyName,
                objBuilderClassName,
                internalBuilderVarName,
                isFieldMandatory,
                isSubField,
                validatorSubFieldName);
        } else {
            setJsonFieldValueStream(setStreamFieldValue, propertyName, objBuilderClassName, internalBuilderVarName);
        }
        if (isFieldMandatory && !isEntityTypeObjectBuilderClass) {
            markPropertyIsSet(setStreamFieldValue, SchemaGeneratorHelper.toValidatorFieldName(propertyName));
        }
        objectBuilderClassBuilder.addMethod(setStreamFieldValue.build());
    }

    private static void setJsonFieldValue(
        final MethodSpec.Builder setBuilderFieldValue,
        final String propertyName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        setBuilderFieldValue
            .addStatement("final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("director.accept($L)", internalBuilderVarName)
            .addCode("schemaObjectBuilder.setJsonFieldValue(\n")
            .addCode("  $L.$L,\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
            .beginControlFlow("  jsonBuilder ->")
            .addStatement("  $L.build(jsonBuilder)", internalBuilderVarName)
            .endControlFlow()
            .addStatement(")");
    }

    private static void setFlattenedFieldValue(
        final MethodSpec.Builder setBuilderFieldValue,
        final String propertyName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFieldMandatory,
        final boolean isSubField,
        final String validatorSubFieldName
    )
    {
        setBuilderFieldValue
            .addCode("schemaObjectBuilder.setFlattenedFieldValue($L.$L, sBuilder-> {\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
            .addStatement("    final $L $L = new $L(sBuilder)", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("    director.accept($L)", internalBuilderVarName)
            .addStatement("    $L.validate()", internalBuilderVarName)
            .addStatement("})");
        if (isFieldMandatory && isSubField) {
            markPropertyIsSet(setBuilderFieldValue, validatorSubFieldName);
        }
    }

    private static void setJsonFieldValueStream(
        final MethodSpec.Builder setStreamFieldValue,
        final String propertyName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        setStreamFieldValue
            .addCode("schemaObjectBuilder.setJsonFieldValue(\n")
            .addCode("  $L.$L,\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
            .addCode("  directors.<Consumer<JsonBuilder>>map(director -> {\n")
            .addStatement("    final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("    director.accept($L)", internalBuilderVarName)
            .addCode("    return jsonBuilder -> {\n")
            .addStatement("      $L.build(jsonBuilder)", internalBuilderVarName)
            .addStatement("    }")
            .addStatement("}))");
    }

    private static void setFlattenedFieldValueStream(
        final MethodSpec.Builder setStreamFieldValue,
        final String propertyName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFieldMandatory,
        final boolean isSubField,
        final String validatorSubFieldName
    )
    {
        setStreamFieldValue
            .addCode("  schemaObjectBuilder.setFlattenedFieldValue($L.$L,\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
            .addCode("    directors.<Consumer<SchemaObjectBuilder>>map(director -> {\n")
            .addCode("    return sBuilder -> {\n")
            .addStatement("      final $L $L = new $L(sBuilder)", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("      director.accept($L)", internalBuilderVarName)
            .addStatement("      $L.validate()", internalBuilderVarName)
            .addStatement("    }")
            .addStatement("}))");
        if (isFieldMandatory && isSubField) {
            markPropertyIsSet(setStreamFieldValue, validatorSubFieldName);
        }
    }

    private static void addBuilderListParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final ParameterizedTypeName builderTypeName
    )
    {
        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(List.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec setListFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName)
            .addStatement("set$L(directors.stream())", fieldFunctionName)
            .build();

        objectBuilderClassBuilder.addMethod(setListFieldValue);
    }

    private static void addNestedObjectBuilderParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String internalVarName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFlattened
    )
    {
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "director")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setBuilderFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName);
        if (isFlattened) {
            setBuilderFieldValue
                .addStatement(
                    "final $L $L = new $L(this.schemaObjectBuilder)",
                    objBuilderClassName, internalBuilderVarName, objBuilderClassName);
        } else {
            setBuilderFieldValue
                .addStatement("final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName);
        }
        setBuilderFieldValue
            .addStatement("director.accept($L)", internalBuilderVarName)
            .addStatement("$L = new ArrayList<>()", internalVarName)
            .addStatement("$L.add($L)", internalVarName, internalBuilderVarName);

        objectBuilderClassBuilder.addMethod(setBuilderFieldValue.build());
    }

    private static void addNestedObjectBuilderStreamParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String internalVarName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFlattened
    )
    {
        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();
        final MethodSpec.Builder setStreamFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName)
            .addCode("$L = directors.map(director -> {\n", internalVarName);
        if (isFlattened) {
            setStreamFieldValue.addStatement(
                "  final $L $L = new $L(this.schemaObjectBuilder)",
                objBuilderClassName, internalBuilderVarName, objBuilderClassName);
        } else {
            setStreamFieldValue.addStatement("  final $L $L = new $L()",
                                             objBuilderClassName, internalBuilderVarName, objBuilderClassName);
        }
        setStreamFieldValue
            .addStatement("  director.accept($L)", internalBuilderVarName)
            .addStatement("  return $L", internalBuilderVarName)
            .addStatement("}).collect($T.toList())", Collectors.class);

        objectBuilderClassBuilder.addMethod(setStreamFieldValue.build());
    }

    private static void addArrayParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield,
        final String parentFieldName,
        final boolean isParentFieldFlattened,
        final boolean isFieldMandatory,
        final String validatorSubFieldName
    )
    {
        final Class<?> boxedFieldType = PROPERTY_TYPES_LOOKUP.get(fieldTypeValue);
        final Class<?> fieldType = TypeName.get(boxedFieldType).isBoxedPrimitive()
            ? PROPERTY_PRIMITIVE_TYPES_LOOKUP.get(fieldTypeValue)
            : boxedFieldType;
        final String methodNameForType = boxedFieldType.getSimpleName();
        final ParameterSpec arrayParamFieldName = ParameterSpec
            .builder(ArrayTypeName.of(fieldType), "values")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setArrayFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(arrayParamFieldName)
            .varargs(true);

        if (isSubfield) {
            if (isParentFieldFlattened) {
                setArrayFieldValue.addStatement(
                    "schemaObjectBuilder.set$LFieldValue($L.$L.$L, values)",
                    methodNameForType,
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName);
                if (isFieldMandatory) {
                    // Note mandatory field has been set
                    markPropertyIsSet(setArrayFieldValue, validatorSubFieldName);
                }
            } else {
                setArrayFieldValue.addStatement("this.$L = $T.asList(values)", subFieldName, Arrays.class);
            }
        } else {
            setArrayFieldValue.addStatement(
                "schemaObjectBuilder.set$LFieldValue($L.$L, values)",
                methodNameForType, SchemaGeneratorHelper.CLASS_NAME, propertyName);
            if (isFieldMandatory) {
                // Note mandatory field has been set
                markPropertyIsSet(setArrayFieldValue, validatorSubFieldName);
            }
        }
        objectBuilderClassBuilder.addMethod(setArrayFieldValue.build());
    }

    private static void addListParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield,
        final String parentFieldName,
        final boolean isParentFieldFlattened,
        final boolean isFieldMandatory,
        final String validatorSubFieldName
    )
    {
        final Class<?> fieldType = PROPERTY_TYPES_LOOKUP.get(fieldTypeValue);
        final String methodNameForType = fieldType.getSimpleName();
        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(
                ParameterizedTypeName.get(ClassName.get(List.class), TypeName.get(fieldType)),
                "values")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setListFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName);

        if (isSubfield) {
            if (isParentFieldFlattened) {
                setListFieldValue.addStatement(
                    "schemaObjectBuilder.set$LFieldValue($L.$L.$L, values)",
                    methodNameForType,
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName);
                if (isFieldMandatory) {
                    // Note mandatory field has been set
                    markPropertyIsSet(setListFieldValue, validatorSubFieldName);
                }
            } else {
                setListFieldValue.addStatement("this.$L = values", subFieldName);
            }
        } else {
            setListFieldValue.addStatement(
                "schemaObjectBuilder.set$LFieldValue($L.$L, values)",
                methodNameForType, SchemaGeneratorHelper.CLASS_NAME, propertyName);
            if (isFieldMandatory) {
                // Note mandatory field has been set
                markPropertyIsSet(setListFieldValue, validatorSubFieldName);
            }
        }

        objectBuilderClassBuilder.addMethod(setListFieldValue.build());
    }

    private static void addSingleValueAddMethod(
        final Builder objectBuilderClassBuilder,
        final ParameterSpec paramSingleFieldValue,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield,
        final String parentFieldName,
        final boolean isParentFieldFlattened,
        final boolean isFieldMandatory,
        final String validatorSubFieldName
    )
    {
        final Class<?> boxedFieldType = PROPERTY_TYPES_LOOKUP.get(fieldTypeValue);
        final Class<?> fieldType = TypeName.get(boxedFieldType).isBoxedPrimitive()
            ? PROPERTY_PRIMITIVE_TYPES_LOOKUP.get(fieldTypeValue)
            : boxedFieldType;
        final String methodNameForType = boxedFieldType.getSimpleName();
        final MethodSpec.Builder addFieldValue = MethodSpec.methodBuilder("add" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(paramSingleFieldValue);

        if (isSubfield) {
            if (isParentFieldFlattened) {
                addFieldValue.addStatement(
                    "schemaObjectBuilder.add$LFieldValue($L.$L.$L, value)",
                    methodNameForType,
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName);
                if (isFieldMandatory) {
                    // Note mandatory field has been set
                    markPropertyIsSet(addFieldValue, validatorSubFieldName);
                }
            } else {
                addFieldValue.beginControlFlow("if ($L == null)", subFieldName);
                addFieldValue.addStatement(
                    "this.$L = new $T()",
                    subFieldName,
                    ParameterizedTypeName.get(ClassName.get(ArrayList.class), TypeName.get(fieldType)));
                addFieldValue.endControlFlow();
                addFieldValue.addStatement("this.$L.add(value)", subFieldName);
            }
        } else {
            addFieldValue.addStatement(
                "schemaObjectBuilder.add$LFieldValue($L.$L, value)",
                methodNameForType, SchemaGeneratorHelper.CLASS_NAME, propertyName);
            if (isFieldMandatory) {
                // Note mandatory field has been set
                markPropertyIsSet(addFieldValue, validatorSubFieldName);
            }
        }

        objectBuilderClassBuilder.addMethod(addFieldValue.build());
    }
}
