/*
 * Copyright 2022 Micro Focus or one of its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.fileanalysissuite.adaptersdk.schema.generator;

import com.fasterxml.jackson.databind.JsonNode;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeSpec.Builder;

import io.github.fileanalysissuite.adaptersdk.schema.builders.JsonBuilder;
import io.github.fileanalysissuite.adaptersdk.schema.builders.SchemaObjectBuilder;
import java.io.IOException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import org.codehaus.plexus.util.StringUtils;

final class SchemaObjectBuilderGenerator
{
    private static final String BUILDER_CLASS_NAME = "AdapterSdkSchemaObjectBuilder";
    private static final Map<String, Class> PROPERTY_TYPES_LOOKUP = new HashMap<String, Class>() {
        {
            put("STRING", String.class);
            put("FULLTEXT", String.class);
            put("LONG", Long.class);
            put("DOUBLE", Double.class);
            put("INTEGER", Integer.class);
            put("BOOLEAN", Boolean.class);
            put("DATETIME", Instant.class);
        }
    };

    private final Filer filer;
    private final JsonNode schemaNode;
    private JsonNode typesNode;

    public SchemaObjectBuilderGenerator(final Filer filer, final JsonNode schemaNode)
    {
        this.filer = filer;
        this.schemaNode = schemaNode;
        this.typesNode = schemaNode.get("types");
    }

    public boolean process()
    {
        createSchemaObjectBuilder();

        return false;
    }

    private void createSchemaObjectBuilder()
    {
        final TypeSpec.Builder schemaClassBuilder = TypeSpec.classBuilder(BUILDER_CLASS_NAME)
            .addModifiers(Modifier.PUBLIC, Modifier.FINAL);

        final FieldSpec field = FieldSpec
            .builder(SchemaObjectBuilder.class, "schemaObjectBuilder")
            .addModifiers(new Modifier[]{Modifier.PRIVATE, Modifier.FINAL})
            .build();

        schemaClassBuilder.addField(field);

        final MethodSpec constructor = MethodSpec
            .constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addParameter(SchemaObjectBuilder.class, "schemaObjectBuilder", Modifier.FINAL)
            .addStatement("this.schemaObjectBuilder = schemaObjectBuilder")
            .build();

        schemaClassBuilder.addMethod(constructor);

        addPropertySetters(schemaClassBuilder, null, schemaNode.get("fields"), new String[0], new String());

        final JavaFile javaFile = JavaFile.builder(SchemaGeneratorHelper.PACKAGE_NAME, schemaClassBuilder.build())
            .addFileComment("\nThis file is auto-generated by SchemaGenerator\n").build();

        try {
            javaFile.writeTo(filer);
        } catch (final IOException e) {
            throw new RuntimeException("Unable to write out generated schema builder file", e);
        }
    }

    private void addPropertySetters(
        final Builder objectBuilderClassBuilder,
        MethodSpec.Builder buildFunctionBuilder,
        final JsonNode entityDef,
        final String[] path,
        final String parentFieldName
    )
    {
        final Iterator<Entry<String, JsonNode>> propertyIterator = entityDef.fields();

        final boolean isSubfield = path.length > 0;

        while (propertyIterator.hasNext()) {
            final Entry<String, JsonNode> property = propertyIterator.next();
            final JsonNode fieldAttributes = property.getValue();

            final String propertyName = property.getKey();

            final String fieldType = fieldAttributes.get("type").textValue();

            final int endOfTypeDimension = fieldType.lastIndexOf('[');

            final String fieldTypeValue = endOfTypeDimension > 0 ? fieldType.substring(0, endOfTypeDimension) : fieldType;

            final int numberOfDimensions = endOfTypeDimension > 0 ? StringUtils.countMatches(fieldType, "[]") : 0;

            final String fldEncoding
                = fieldAttributes.hasNonNull("objectEncoding")
                ? fieldAttributes.get("objectEncoding").textValue()
                : "json";
            // TODO: flattened does not need 'build' function and instance / state variables
            final boolean fldIsMultiValued = fieldType.endsWith("[]");

            final boolean fldIsMandatory
                = fieldAttributes.hasNonNull("mandatory")
                ? fieldAttributes.get("mandatory").booleanValue()
                : false;

            final String fieldFunctionName = SchemaGeneratorHelper.toProperCase(propertyName);

            final MethodSpec.Builder clearFieldMethodBuilder = MethodSpec.methodBuilder("clear" + fieldFunctionName)
                .addModifiers(Modifier.PUBLIC);

            if (!SchemaGeneratorHelper.PROPERTY_TYPES.contains(fieldType)) {
                // Non-primitive/Object type field
                final String objBuilderClassName = fieldFunctionName + "ObjectBuilder";
                final String[] newPath = SchemaGeneratorHelper.addExtraElement(path, objBuilderClassName);
                final String fullName = isSubfield ? parentFieldName + "." + propertyName : propertyName;

                final ParameterizedTypeName builderTypeName = ParameterizedTypeName
                    .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

                final String internalVarName = SchemaGeneratorHelper.toFieldNameCase(propertyName);
                final String internalBuilderVarName = internalVarName + "Builder";

                if (parentFieldName.isEmpty()) {
                    // first level object type field
                    // TODO: "ocr[][]" // every additional [] would need a ListBuilder
                    // TODO: Are multi-dimensional fields allowed at any level?
                    if(numberOfDimensions > 1) {
                        // Multi-dimensional field
                        // Add an list object builder class for property
                        final String listObjBuilderClassName = fieldFunctionName + "ListObjectBuilder";
                        final TypeSpec.Builder fieldListObjectBuilderClassBuiler = TypeSpec.classBuilder(listObjBuilderClassName)
                            .addModifiers(new Modifier[]{Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL})
                            .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE)
                            .build());

                        // Add instance variable for list of field object builders
                        final String listName = internalVarName + "Builders";
                        final FieldSpec fieldObjBuilderList = FieldSpec
                            .builder(ParameterizedTypeName.get(
                                ClassName.get(List.class), ClassName.get("", objBuilderClassName)), listName)
                            .addModifiers(new Modifier[]{Modifier.PRIVATE})
                            .build();
                        fieldListObjectBuilderClassBuiler.addField(fieldObjBuilderList);

                        // Add set function Builder param
                        addFieldListObjectBuilderBuilderParamSetter(
                            fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName, listName);

                        // Add set function with Stream param
                        addFieldListObjectBuilderStreamParamSetter(
                            fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName, listName);

                        // Add set function with List param
                        addFieldListObjectBuilderListParamSetter(fieldListObjectBuilderClassBuiler, objBuilderClassName);

                        // Add clear field method
                        addFieldListObjectBuilderClearFunction(fieldListObjectBuilderClassBuiler, listName);

                        // Add build method
                        addFieldListObjectBuilderBuildFunction(fieldListObjectBuilderClassBuiler, objBuilderClassName, listName);

                        objectBuilderClassBuilder.addType(fieldListObjectBuilderClassBuiler.build());

                        final ParameterizedTypeName listBuilderTypeName = ParameterizedTypeName
                            .get(ClassName.get(Consumer.class), ClassName.get("", listObjBuilderClassName));

                        // Add set function Builder param
                        addBuilderParamSetter(
                            objectBuilderClassBuilder,
                            fieldFunctionName,
                            fullName,
                            listBuilderTypeName,
                            listObjBuilderClassName,
                            internalBuilderVarName);

                        // Add set function with Stream param
                        addBuilderStreamParamSetter(
                            objectBuilderClassBuilder,
                            fieldFunctionName,
                            fullName,
                            listBuilderTypeName,
                            listObjBuilderClassName,
                            internalBuilderVarName);

                        // Add set function with List param
                        addBuilderListParamSetter(
                            objectBuilderClassBuilder,
                            fieldFunctionName,
                            listBuilderTypeName,
                            listObjBuilderClassName,
                            internalBuilderVarName);
                    } else {
                        // Single dimension field
                        // Add set function Builder param
                        addBuilderParamSetter(
                            objectBuilderClassBuilder,
                            fieldFunctionName,
                            fullName,
                            builderTypeName,
                            objBuilderClassName,
                            internalBuilderVarName);

                        // Add set function with Stream param
                        addBuilderStreamParamSetter(
                            objectBuilderClassBuilder,
                            fieldFunctionName,
                            fullName,
                            builderTypeName,
                            objBuilderClassName,
                            internalBuilderVarName);
                    }
                    // Add clear field method
                    clearFieldMethodBuilder
                        .addStatement("schemaObjectBuilder.clearField($L.$L)", SchemaGeneratorHelper.CLASS_NAME, fullName);
                }
                else {
                    // next level object type field
                    final FieldSpec nonPrimitiveField = FieldSpec
                        .builder(
                            fldIsMultiValued
                                ? ParameterizedTypeName.get(
                                    ClassName.get(List.class), ClassName.get("", objBuilderClassName))
                                : ClassName.get("", objBuilderClassName),
                                internalVarName)
                        .addModifiers(new Modifier[]{Modifier.PRIVATE})
                        .build();
                    objectBuilderClassBuilder.addField(nonPrimitiveField);

                    // Add nonPrimitiveField set function Builder param
                    addNestedObjectBuilderParamSetter(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        internalVarName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName);

                    // Add nonPrimitiveField set function with Stream param
                    addNestedObjectBuilderStreamParamSetter(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        internalVarName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName);

                    // Add clear field method
                    clearFieldMethodBuilder.addStatement("$L = null", internalVarName);

                    // Write Json field
                    writeJsonFields(
                        buildFunctionBuilder,
                        fieldTypeValue,
                        fldIsMandatory,
                        fldIsMultiValued,
                        parentFieldName,
                        propertyName,
                        internalVarName,
                        objBuilderClassName);
                }

                if (numberOfDimensions <= 1) {
                    // Add set function with List param
                    addBuilderListParamSetter(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        builderTypeName,
                        objBuilderClassName,
                        internalBuilderVarName);
                }

                // Add an object builder class for property
                final TypeSpec.Builder fieldObjectBuilderClassBuiler = TypeSpec.classBuilder(objBuilderClassName)
                    .addModifiers(new Modifier[]{Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL})
                    .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE)
                    .build());

                final int endOfTypeName = fieldType.indexOf('[');
                final String refTypeName = endOfTypeName > 0 ? fieldType.substring(0, endOfTypeName) : fieldType;
                final JsonNode subentityDef = typesNode.get(refTypeName);

                // Create a build method
                buildFunctionBuilder = MethodSpec.methodBuilder("build")
                    .addModifiers(Modifier.PRIVATE)
                    .addParameter(ParameterSpec.builder(JsonBuilder.class, "jsonBuilder").addModifiers(Modifier.FINAL).build())
                    .addStatement("jsonBuilder.writeStartObject()");

                // Add all the sub-fields of this non-primitive property
                addPropertySetters(fieldObjectBuilderClassBuiler, buildFunctionBuilder, subentityDef, newPath, fullName);

                buildFunctionBuilder.addStatement("jsonBuilder.writeEndObject()");
                fieldObjectBuilderClassBuiler.addMethod(buildFunctionBuilder.build());

                objectBuilderClassBuilder.addType(fieldObjectBuilderClassBuiler.build());
            } else {
                // Primitive type field
                final ParameterSpec paramSingleFieldValue = ParameterSpec
                    .builder(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue), "value")
                    .addModifiers(Modifier.FINAL)
                    .build();

                final MethodSpec.Builder setSingleFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
                    .addModifiers(Modifier.PUBLIC)
                    .addParameter(paramSingleFieldValue);

                final String subFieldName = SchemaGeneratorHelper.toFieldNameCase(propertyName);

                // Add setter variations for multi-valued field
                if (fldIsMultiValued) {
                    // Set array value
                    addArrayParamSetter(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        propertyName,
                        subFieldName,
                        fieldTypeValue,
                        isSubfield);

                    // Set List value
                    addListParamSetter(
                        objectBuilderClassBuilder,
                        fieldFunctionName,
                        propertyName,
                        subFieldName,
                        fieldTypeValue,
                        isSubfield);

                    // Add single value
                    addSingleValueAddFunction(
                        objectBuilderClassBuilder,
                        paramSingleFieldValue,
                        fieldFunctionName,
                        propertyName,
                        subFieldName,
                        fieldTypeValue,
                        isSubfield);
                }

                if(isSubfield) {
                    // Add instance variable for subField
                    final FieldSpec field = FieldSpec
                        .builder(
                            fldIsMultiValued
                                ? ParameterizedTypeName.get(
                                    ClassName.get(List.class), ClassName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue)))
                                : ClassName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue)),
                            subFieldName)
                        .addModifiers(new Modifier[]{Modifier.PRIVATE})
                        .build();
                    objectBuilderClassBuilder.addField(field);

                    // Add clear function body
                    clearFieldMethodBuilder.addStatement(subFieldName + " = null");

                    // write Json fields
                    writeJsonFields(
                        buildFunctionBuilder,
                        fieldTypeValue,
                        fldIsMandatory,
                        fldIsMultiValued,
                        parentFieldName,
                        propertyName,
                        subFieldName,
                        null);

                    // Add setters for multi-valued subfield
                    if (fldIsMultiValued) {
                        // Add set single value function body
                        setSingleFieldValue.addStatement(
                            "this.$L = new $T()",
                            subFieldName,
                            ParameterizedTypeName
                                .get(ClassName.get(ArrayList.class), TypeName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue))));
                        setSingleFieldValue.addStatement("this.$L.add(value)", subFieldName);
                    } else {
                        setSingleFieldValue.addStatement("this.$L = value", subFieldName);
                    }
                } else {
                    // TODO: how to ensure mandatory field is set?
                    clearFieldMethodBuilder
                        .addStatement("schemaObjectBuilder.clearField($L.$L)", SchemaGeneratorHelper.CLASS_NAME, propertyName);

                    setSingleFieldValue.addStatement(
                        "schemaObjectBuilder.set$LFieldValue($L.$L, value)",
                        PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), SchemaGeneratorHelper.CLASS_NAME, propertyName);

                }
                // Add single value setter method
                objectBuilderClassBuilder.addMethod(setSingleFieldValue.build());

            }
            // Add clear field method
            objectBuilderClassBuilder.addMethod(clearFieldMethodBuilder.build());
        }
    }

    private static void addFieldListObjectBuilderBuilderParamSetter(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName,
        final String listName
    )
    {
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "builder")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec setBuilderFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName)
            .addStatement("final $L $L = new $L()", objBuilderClassName, varName, objBuilderClassName)
            .addStatement("builder.accept($L)", varName)
            .addStatement("$L = new ArrayList<>()", listName)
            .addStatement("$L.add($L)", listName, varName)
            .build();

        fieldListObjectBuilderClassBuiler.addMethod(setBuilderFieldValue);
    }

    private static void addFieldListObjectBuilderStreamParamSetter(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName,
        final String listName
    )
    {
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "builders")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec setStreamFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName)
            .addCode("$L = builders.map(builder -> {\n", listName)
            .addStatement("  final $L $L = new $L()", objBuilderClassName, varName, objBuilderClassName)
            .addStatement("  builder.accept($L)", varName)
            .addStatement("  return $L", varName)
            .addStatement("}).collect($T.toList())", Collectors.class)
            .build();

        fieldListObjectBuilderClassBuiler.addMethod(setStreamFieldValue);
    }

    private static void addFieldListObjectBuilderListParamSetter(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName
    )
    {
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(List.class), builderTypeName), "builders")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec setBuilderFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName)
            .addStatement("set(builders.stream())")
            .build();

        fieldListObjectBuilderClassBuiler.addMethod(setBuilderFieldValue);
    }

    private static void addFieldListObjectBuilderClearFunction(
        final Builder fieldListObjectBuilderClassBuiler,
        final String listName
    )
    {
        final MethodSpec setBuilderFieldValue = MethodSpec.methodBuilder("clear")
            .addModifiers(Modifier.PUBLIC)
            .addStatement("$L = null", listName)
            .build();

        fieldListObjectBuilderClassBuiler.addMethod(setBuilderFieldValue);
    }

    private static void addFieldListObjectBuilderBuildFunction(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String listName
    )
    {
        final MethodSpec buildFunctionBuilder = MethodSpec.methodBuilder("build")
            .addModifiers(Modifier.PRIVATE)
            .addParameter(ParameterSpec.builder(JsonBuilder.class, "jsonBuilder")
            .addModifiers(Modifier.FINAL).build())
            .addStatement("jsonBuilder.writeStartArray()")
            .beginControlFlow("if ($L != null)", listName)
            .beginControlFlow("for (final $L value : $L)", objBuilderClassName, listName)
            .addStatement("value.build(jsonBuilder)")
            .endControlFlow()
            .endControlFlow()
            .addStatement("jsonBuilder.writeEndArray()")
            .build();

        fieldListObjectBuilderClassBuiler.addMethod(buildFunctionBuilder);
    }

    private static void writeJsonFields(
        final MethodSpec.Builder buildFunctionBuilder,
        final String fieldTypeValue,
        final boolean fldIsMandatory,
        final boolean fldIsMultiValued,
        final String parentFieldName,
        final String propertyName,
        final String subFieldName,
        final String objBuilderClassName)
    {
        if(fldIsMandatory) {
            buildFunctionBuilder
                .beginControlFlow("if ($L == null)", subFieldName)
                .addStatement(
                    "throw new IllegalArgumentException(\"Mandatory field '$L.$L.$L' is not set\")",
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName)
                .nextControlFlow("else");
        } else {
            buildFunctionBuilder.beginControlFlow("if ($L != null)", subFieldName);
        }
        buildFunctionBuilder.addStatement(
            "jsonBuilder.writeFieldName($L.$L.$L.getFieldName())", SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName);

        if (fldIsMultiValued) {
            // Add build function body
            buildFunctionBuilder.addStatement("jsonBuilder.writeStartArray()");

            if (objBuilderClassName == null) {
                buildFunctionBuilder.beginControlFlow(
                    "for(final $L value : $L)", PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), subFieldName);
                buildFunctionBuilder.addStatement(
                    "jsonBuilder.write$L(value)", PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName());
            } else {
                buildFunctionBuilder.beginControlFlow("for(final $L value : $L)", objBuilderClassName, subFieldName);
                buildFunctionBuilder.addStatement("value.build(jsonBuilder)");
            }
            buildFunctionBuilder.endControlFlow();

            buildFunctionBuilder.addStatement("jsonBuilder.writeEndArray()");
        } else {
            buildFunctionBuilder.addStatement(
                "jsonBuilder.write$L($L)", PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), subFieldName);
        }
        buildFunctionBuilder.endControlFlow();
    }

    private static void addBuilderParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "builder")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec setBuilderFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName)
            .addStatement("final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("builder.accept($L)", internalBuilderVarName)
            .addCode("schemaObjectBuilder.setJsonFieldValue(\n")
            .addCode("  $L.$L,\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
            .beginControlFlow("  jsonBuilder ->")
            .addStatement("  $L.build(jsonBuilder)", internalBuilderVarName)
            .endControlFlow()
            .addStatement(")")
            .build();

        objectBuilderClassBuilder.addMethod(setBuilderFieldValue);
    }

    private static void addBuilderStreamParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "builders")
            .addModifiers(Modifier.FINAL)
            .build();
        final MethodSpec setStreamFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName)
            .addCode("schemaObjectBuilder.setJsonFieldValue(\n")
            .addCode("  $L.$L,\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
            .addCode("  builders.<Consumer<JsonBuilder>>map(builder -> {\n")
            .addStatement("    final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("    builder.accept($L)", internalBuilderVarName)
            .addCode("    return jsonBuilder -> {\n")
            .addStatement("      $L.build(jsonBuilder)", internalBuilderVarName)
            .addStatement("    }")
            .addStatement("}))")
            .build();

        objectBuilderClassBuilder.addMethod(setStreamFieldValue);
    }

    private static void addBuilderListParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(List.class), builderTypeName), "builders")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec setListFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName)
            .addStatement("set$L(builders.stream())", fieldFunctionName)
            .build();

        objectBuilderClassBuilder.addMethod(setListFieldValue);
    }

    private static void addNestedObjectBuilderParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String internalVarName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "builder")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec setBuilderFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName)
            .addStatement("final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("builder.accept($L)", internalBuilderVarName)
            .addStatement("$L = new ArrayList<>()", internalVarName)
            .addStatement("$L.add($L)", internalVarName, internalBuilderVarName)
            .build();

        objectBuilderClassBuilder.addMethod(setBuilderFieldValue);
    }

    private static void addNestedObjectBuilderStreamParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String internalVarName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "builders")
            .addModifiers(Modifier.FINAL)
            .build();
        final MethodSpec setStreamFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName)
            .addCode("$L = builders.map(builder -> {\n", internalVarName)
            .addStatement("  final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("  builder.accept($L)", internalBuilderVarName)
            .addStatement("  return $L", internalBuilderVarName)
            .addStatement("}).collect($T.toList())", Collectors.class)
            .build();

        objectBuilderClassBuilder.addMethod(setStreamFieldValue);
    }

    private static void addArrayParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield
    )
    {
        final ParameterSpec arrayParamFieldName = ParameterSpec
            .builder( ArrayTypeName.of(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue)), "values")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setArrayFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(arrayParamFieldName)
            .varargs(true);

        if (isSubfield) {
            setArrayFieldValue.addStatement("this.$L = $T.asList(values)", subFieldName, Arrays.class);
        } else {
            setArrayFieldValue.addStatement(
                "schemaObjectBuilder.set$LFieldValue($L.$L, values)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), SchemaGeneratorHelper.CLASS_NAME, propertyName);
        }
        objectBuilderClassBuilder.addMethod(setArrayFieldValue.build());
    }

    private static void addListParamSetter(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield
    )
    {
        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(
                ParameterizedTypeName.get(ClassName.get(List.class), TypeName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue))),
                "values")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setListFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName);

        if (isSubfield) {
            setListFieldValue.addStatement("this.$L = values", subFieldName);
        } else {
            setListFieldValue.addStatement(
                "schemaObjectBuilder.set$LFieldValue($L.$L, values)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), SchemaGeneratorHelper.CLASS_NAME, propertyName);
        }

        objectBuilderClassBuilder.addMethod(setListFieldValue.build());
    }

    private static void addSingleValueAddFunction(
        final Builder objectBuilderClassBuilder,
        final ParameterSpec paramSingleFieldValue,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield
    )
    {
        final MethodSpec.Builder addFieldValue = MethodSpec.methodBuilder("add" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(paramSingleFieldValue);

        if (isSubfield) {
            addFieldValue.beginControlFlow("if ($L == null)", subFieldName);
            addFieldValue.addStatement(
                "this.$L = new $T()",
                subFieldName,
                ParameterizedTypeName.get(ClassName.get(ArrayList.class), TypeName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue))));
            addFieldValue.endControlFlow();
            addFieldValue.addStatement("this.$L.add(value)", subFieldName);
        } else {
            addFieldValue.addStatement(
                "schemaObjectBuilder.add$LFieldValue($L.$L, value)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), SchemaGeneratorHelper.CLASS_NAME, propertyName);
        }

        objectBuilderClassBuilder.addMethod(addFieldValue.build());
    }

}
