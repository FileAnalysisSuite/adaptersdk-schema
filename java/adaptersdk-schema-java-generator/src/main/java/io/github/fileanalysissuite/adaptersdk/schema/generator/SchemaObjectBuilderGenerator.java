/*
 * Copyright 2022 Micro Focus or one of its affiliates.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.fileanalysissuite.adaptersdk.schema.generator;

import com.fasterxml.jackson.databind.JsonNode;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeSpec.Builder;

import io.github.fileanalysissuite.adaptersdk.schema.builders.JsonBuilder;
import io.github.fileanalysissuite.adaptersdk.schema.builders.SchemaObjectBuilder;
import java.io.IOException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import org.codehaus.plexus.util.StringUtils;

final class SchemaObjectBuilderGenerator
{
    private static final Logger LOGGER = Logger.getLogger("SchemaObjectBuilderGenerator");

    private static final String BUILDER_CLASS_NAME = "AdapterSdkSchemaObjectBuilder";
    private static final Map<String, Class> PROPERTY_TYPES_LOOKUP = new HashMap<String, Class>() {
        {
            put("STRING", String.class);
            put("FULLTEXT", String.class);
            put("LONG", Long.class);
            put("DOUBLE", Double.class);
            put("INTEGER", Integer.class);
            put("BOOLEAN", Boolean.class);
            put("DATETIME", Instant.class);
        }
    };

    private final Filer filer;
    private final JsonNode schemaNode;
    private JsonNode typesNode;

    public SchemaObjectBuilderGenerator(final Filer filer, final JsonNode schemaNode)
    {
        this.filer = filer;
        this.schemaNode = schemaNode;
        this.typesNode = schemaNode.get("types");
    }

    public boolean process()
    {
        LOGGER.log(Level.INFO, "Start process...");
        final TypeSpec.Builder schemaClassBuilder
            = createSchemaObjectBuilder(BUILDER_CLASS_NAME, null, schemaNode.get("fields"), new String[0], new String(), true, false);

        final JavaFile javaFile = JavaFile.builder(SchemaGeneratorHelper.PACKAGE_NAME, schemaClassBuilder.build())
            .addFileComment("\nThis file is auto-generated by SchemaGenerator\n").build();

        try {
            javaFile.writeTo(filer);
        } catch (final IOException e) {
            throw new RuntimeException("Unable to write out generated schema builder file", e);
        }
        return false;
    }

    private TypeSpec.Builder createSchemaObjectBuilder(
        final String builderClassName,
        MethodSpec.Builder buildFunctionBuilder,
        final JsonNode schemaNode,
        final String[] path,
        final String parentFieldName,
        final boolean flattenedParentField,
        final boolean isStatic)
    {
        final String msg
        = "createSchemaObjectBuilder : " + builderClassName 
            + ", " + buildFunctionBuilder
            + ", " + schemaNode
            + ", " + path
            + ", " + parentFieldName
            + ", " + flattenedParentField
            + ", " + isStatic;
        LOGGER.log(Level.INFO, msg);
        final Modifier[] modifiers = isStatic
            ? new Modifier[]{Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL}
            : new Modifier[]{Modifier.PUBLIC, Modifier.FINAL};
        final TypeSpec.Builder schemaClassBuilder = TypeSpec.classBuilder(builderClassName)
            .addModifiers(modifiers);

        addSchemaObjectBuilderFieldAndCtor(schemaClassBuilder);

        addPropertySetters(schemaClassBuilder, buildFunctionBuilder, schemaNode, path, parentFieldName, flattenedParentField);

        return schemaClassBuilder;
    }

    private static void addSchemaObjectBuilderFieldAndCtor(final TypeSpec.Builder schemaClassBuilder)
    {
        final String msg
        = "addSchemaObjectBuilderFieldAndCtor : " + schemaClassBuilder;
        LOGGER.log(Level.INFO, msg);
        final FieldSpec field = FieldSpec
            .builder(SchemaObjectBuilder.class, "schemaObjectBuilder")
            .addModifiers(Modifier.PRIVATE, Modifier.FINAL)
            .build();

        schemaClassBuilder.addField(field);

        final MethodSpec constructor = MethodSpec
            .constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addParameter(SchemaObjectBuilder.class, "schemaObjectBuilder", Modifier.FINAL)
            .addStatement("this.schemaObjectBuilder = schemaObjectBuilder")
            .build();

        schemaClassBuilder.addMethod(constructor);
    }

    private void addPropertySetters(
        final TypeSpec.Builder objectBuilderClassBuilder,
        MethodSpec.Builder buildFunctionBuilder,
        final JsonNode entityDef,
        final String[] path,
        final String parentFieldName,
        final boolean flattenedParentField
    )
    {
        final String msg
        = "addPropertySetters : " + objectBuilderClassBuilder
            + ", " + buildFunctionBuilder
            + ", " + entityDef
            + ", " + path
            + ", " + parentFieldName
            + ", " + flattenedParentField;
        LOGGER.log(Level.INFO, msg);
        /*
            flattened + json + flattened ====> not possible
            flattened + flattened
            flattened + json
            flattened + flattened + flattened + flattened + json
            json + json + json - starts with json, all nested entities have to be json
        */
        LOGGER.log(Level.INFO, "addPropertySetters for entityDef: " + entityDef);
        final Iterator<Entry<String, JsonNode>> propertyIterator = entityDef.fields();

        final boolean isSubfield = path.length > 0;

        while (propertyIterator.hasNext()) {
            final Entry<String, JsonNode> property = propertyIterator.next();
            final JsonNode fieldAttributes = property.getValue();

            final String propertyName = property.getKey();

            final String fieldType = fieldAttributes.get("type").textValue();

            final int endOfTypeDimension = fieldType.lastIndexOf('[');

            final String fieldTypeValue = endOfTypeDimension > 0 ? fieldType.substring(0, endOfTypeDimension) : fieldType;

            final int numberOfDimensions = endOfTypeDimension > 0 ? StringUtils.countMatches(fieldType, "[]") : 0;

            final boolean isFlattened
                = fieldAttributes.hasNonNull("objectEncoding")
                ? fieldAttributes.get("objectEncoding").textValue().equals("flattened")
                : false;

            final boolean fldIsMultiValued = fieldType.endsWith("[]");

            final boolean fldIsMandatory
                = fieldAttributes.hasNonNull("mandatory")
                ? fieldAttributes.get("mandatory").booleanValue()
                : false;

            final String fieldFunctionName = SchemaGeneratorHelper.toProperCase(propertyName);

            LOGGER.log(Level.INFO, "Processing: " + propertyName + " of type : " + fieldType + " isFlattened? " + isFlattened);
            if (!SchemaGeneratorHelper.PROPERTY_TYPES.contains(fieldType)) {
                // Non-primitive/Object type field
                addEntityTypeFieldSetters(
                    objectBuilderClassBuilder,
                    buildFunctionBuilder,
                    fieldFunctionName,
                    fieldType,
                    fieldTypeValue,
                    fldIsMandatory,
                    fldIsMultiValued,
                    numberOfDimensions,
                    isSubfield,
                    path,
                    propertyName,
                    parentFieldName,
                    isFlattened
                );
            } else {
                // Primitive type field
                addPrimitiveFieldSetters(
                    objectBuilderClassBuilder,
                    buildFunctionBuilder,
                    fieldFunctionName,
                    fieldTypeValue,
                    fldIsMandatory,
                    fldIsMultiValued,
                    isSubfield,
                    propertyName,
                    parentFieldName,
                    flattenedParentField
                );
            }
        }
    }

    private void addEntityTypeFieldSetters(
        final TypeSpec.Builder objectBuilderClassBuilder,
        MethodSpec.Builder buildFunctionBuilder,
        final String fieldFunctionName,
        final String fieldType,
        final String fieldTypeValue,
        final boolean fldIsMandatory,
        final boolean fldIsMultiValued,
        final int numberOfDimensions,
        final boolean isSubfield,
        final String[] path,
        final String propertyName,
        final String parentFieldName,
        final boolean isFlattened
    )
    {
        final MethodSpec.Builder clearFieldMethodBuilder = MethodSpec.methodBuilder("clear" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC);
        final String objBuilderClassName = fieldFunctionName + "ObjectBuilder";
        final int endOfTypeName = fieldType.indexOf('[');
        final String refTypeName = endOfTypeName > 0 ? fieldType.substring(0, endOfTypeName) : fieldType;
        final JsonNode subentityDef = typesNode.get(refTypeName);

        System.out.println("subentityDef: " + subentityDef);

        final String[] newPath = SchemaGeneratorHelper.addExtraElement(path, objBuilderClassName);
        final String fullName = isSubfield ? parentFieldName + "." + propertyName : propertyName;

        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final String internalVarName = SchemaGeneratorHelper.toFieldNameCase(propertyName);
        final String internalBuilderVarName = internalVarName + "Builder";

        if (parentFieldName.isEmpty()) {
            // first level object type field
            // TODO: "ocr[][]" // every additional [] would need a ListBuilder
            // TODO: Are multi-dimensional fields allowed at any level? : yes
            // TODO: rename builder to director
            if(numberOfDimensions > 1) {
                // Multi-dimensional field
                // Add an list object builder class for property
                final String suffix = "ObjectBuilder";
                String listName = "";
                for(int i = 0; i < numberOfDimensions; i++) {
                    listName += "List";
                    addListBuilderClass(
                        objectBuilderClassBuilder,
                        objBuilderClassName,
                        fieldFunctionName + listName + suffix,
                        internalVarName,
                        isFlattened);
                }
                final String listObjBuilderClassName = fieldFunctionName + listName + suffix;
                final ParameterizedTypeName listBuilderTypeName = ParameterizedTypeName
                    .get(ClassName.get(Consumer.class), ClassName.get("", listObjBuilderClassName));

                // Add set function Builder param
                addBuilderParamSetterFunction(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    fullName,
                    listBuilderTypeName,
                    listObjBuilderClassName,
                    internalBuilderVarName,
                    isFlattened);

                // Add set function with Stream param
                addBuilderStreamParamSetterFunction(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    fullName,
                    listBuilderTypeName,
                    listObjBuilderClassName,
                    internalBuilderVarName,
                    isFlattened);

                // Add set function with List param
                addBuilderListParamSetterFunction(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    listBuilderTypeName,
                    listObjBuilderClassName,
                    internalBuilderVarName);
            } else {
                // Single dimension field
                // Add set function Builder param
                addBuilderParamSetterFunction(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    fullName,
                    builderTypeName,
                    objBuilderClassName,
                    internalBuilderVarName,
                    isFlattened);

                // Add set function with Stream param
                addBuilderStreamParamSetterFunction(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    fullName,
                    builderTypeName,
                    objBuilderClassName,
                    internalBuilderVarName,
                    isFlattened);
            }
            // Add clear field method
            clearFieldMethodBuilder
                .addStatement("schemaObjectBuilder.clearField($L.$L)", SchemaGeneratorHelper.CLASS_NAME, fullName);
        } else {
            // next level object type field
            if(isFlattened) {
                // TODO
                // Add nonPrimitiveField set function Builder param
                addBuilderParamSetterFunction(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    fullName,
                    builderTypeName,
                    objBuilderClassName,
                    internalBuilderVarName,
                    isFlattened);

                // Add nonPrimitiveField set function with Stream param
                addBuilderStreamParamSetterFunction(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    fullName,
                    builderTypeName,
                    objBuilderClassName,
                    internalBuilderVarName,
                    isFlattened);

                // Add clear field method
                clearFieldMethodBuilder
                    .addStatement("schemaObjectBuilder.clearField($L.$L)", SchemaGeneratorHelper.CLASS_NAME, fullName);
            } else {
                final FieldSpec nonPrimitiveField = FieldSpec
                    .builder(
                        fldIsMultiValued
                            ? ParameterizedTypeName.get(
                                ClassName.get(List.class), ClassName.get("", objBuilderClassName))
                            : ClassName.get("", objBuilderClassName),
                            internalVarName)
                    .addModifiers(new Modifier[]{Modifier.PRIVATE})
                    .build();
                objectBuilderClassBuilder.addField(nonPrimitiveField);

                // Add nonPrimitiveField set function Builder param
                addNestedObjectBuilderParamSetterFunction(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    internalVarName,
                    builderTypeName,
                    objBuilderClassName,
                    internalBuilderVarName,
                    isFlattened);

                // Add nonPrimitiveField set function with Stream param
                addNestedObjectBuilderStreamParamSetterFunction(
                    objectBuilderClassBuilder,
                    fieldFunctionName,
                    internalVarName,
                    builderTypeName,
                    objBuilderClassName,
                    internalBuilderVarName,
                    isFlattened);

                // Add clear field method
                clearFieldMethodBuilder.addStatement("$L = null", internalVarName);

                if(buildFunctionBuilder == null) {
                    // because parent was flattened, but this sub entity is not
                    buildFunctionBuilder = MethodSpec.methodBuilder("build")
                        .addModifiers(Modifier.PRIVATE)
                        .addParameter(ParameterSpec.builder(JsonBuilder.class, "jsonBuilder").addModifiers(Modifier.FINAL).build())
                        .addStatement("jsonBuilder.writeStartObject()");
                }
                // Write Json field
                writeJsonFieldsInBuildFunction(
                    buildFunctionBuilder, // already available
                    fieldTypeValue,
                    fldIsMandatory,
                    fldIsMultiValued,
                    parentFieldName,
                    propertyName,
                    internalVarName,
                    objBuilderClassName);
                // TODO: is this required? buildFunctionBuilder.addStatement("jsonBuilder.writeEndObject()");
            }
        }

        if (numberOfDimensions <= 1) {
            // Add set function with List param
            addBuilderListParamSetterFunction(
                objectBuilderClassBuilder,
                fieldFunctionName,
                builderTypeName,
                objBuilderClassName,
                internalBuilderVarName);
        }

        // Add an object builder class for property
        if(isFlattened) {
            final TypeSpec.Builder fieldObjectBuilderClassBuilder
                = createSchemaObjectBuilder(
                    objBuilderClassName, buildFunctionBuilder, subentityDef, newPath, fullName, true, true);
            objectBuilderClassBuilder.addType(fieldObjectBuilderClassBuilder.build());
        } else {
            final TypeSpec.Builder fieldObjectBuilderClassBuilder = TypeSpec.classBuilder(objBuilderClassName)
            .addModifiers(new Modifier[]{Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL})
            .addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE)
            .build());

            // Create a build method
            final MethodSpec.Builder parentBuilder = buildFunctionBuilder == null ? null : buildFunctionBuilder;
            buildFunctionBuilder = MethodSpec.methodBuilder("build")
                .addModifiers(Modifier.PRIVATE)
                .addParameter(ParameterSpec.builder(JsonBuilder.class, "jsonBuilder").addModifiers(Modifier.FINAL).build())
                .addStatement("jsonBuilder.writeStartObject()");

            // Add all the sub-fields of this non-primitive property
            addPropertySetters(
                fieldObjectBuilderClassBuilder, buildFunctionBuilder, subentityDef, newPath, fullName, false);

            buildFunctionBuilder.addStatement("jsonBuilder.writeEndObject()");
            fieldObjectBuilderClassBuilder.addMethod(buildFunctionBuilder.build());
            if (parentBuilder != null) {
                buildFunctionBuilder = parentBuilder;
            }
            objectBuilderClassBuilder.addType(fieldObjectBuilderClassBuilder.build());
        }
        // Add clear field method
        objectBuilderClassBuilder.addMethod(clearFieldMethodBuilder.build());
    }

    private static void addListBuilderClass(
        final TypeSpec.Builder objectBuilderClassBuilder,
        final String objBuilderClassName,
        final String listObjBuilderClassName,
        final String internalVarName,
        final boolean isFlattened
    )
    {
        final TypeSpec.Builder fieldListObjectBuilderClassBuiler = TypeSpec.classBuilder(listObjBuilderClassName)
            .addModifiers(new Modifier[]{Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL});
        //flattened does not need 'build' function and instance/state variables
        if (isFlattened) {
            addSchemaObjectBuilderFieldAndCtor(fieldListObjectBuilderClassBuiler);

            // Add set function Builder param
            addFieldListObjectBuilderBuilderParamSetter(
                fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName);

            // Add set function with Stream param
            addFieldListObjectBuilderStreamParamSetter(
                fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName);

            // Add set function with List param
            addFieldListObjectBuilderListParamSetter(fieldListObjectBuilderClassBuiler, objBuilderClassName);

            // Add clear field method
            addFieldListObjectBuilderClearFunction(fieldListObjectBuilderClassBuiler);
        } else {
            fieldListObjectBuilderClassBuiler.addMethod(MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build());

            // Add instance variable for list of field object builders
            final String listName = internalVarName + "Builders";
            final FieldSpec fieldObjBuilderList = FieldSpec
                .builder(ParameterizedTypeName.get(
                    ClassName.get(List.class), ClassName.get("", objBuilderClassName)), listName)
                .addModifiers(new Modifier[]{Modifier.PRIVATE})
                .build();
            fieldListObjectBuilderClassBuiler.addField(fieldObjBuilderList);

            // Add set function Builder param
            addFieldListObjectBuilderBuilderParamSetter(
                fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName, listName);

            // Add set function with Stream param
            addFieldListObjectBuilderStreamParamSetter(
                fieldListObjectBuilderClassBuiler, objBuilderClassName, internalVarName, listName);

            // Add set function with List param
            addFieldListObjectBuilderListParamSetter(fieldListObjectBuilderClassBuiler, objBuilderClassName);

            // Add clear field method
            addFieldListObjectBuilderClearFunction(fieldListObjectBuilderClassBuiler, listName);

            // Add build method
            addFieldListObjectBuilderBuildFunction(fieldListObjectBuilderClassBuiler, objBuilderClassName, listName);
        }

        objectBuilderClassBuilder.addType(fieldListObjectBuilderClassBuiler.build());
    }

    private static void addPrimitiveFieldSetters(
        final TypeSpec.Builder objectBuilderClassBuilder,
        final MethodSpec.Builder buildFunctionBuilder,
        final String fieldFunctionName,
        final String fieldTypeValue,
        final boolean fldIsMandatory,
        final boolean fldIsMultiValued,
        final boolean isSubfield,
        final String propertyName,
        final String parentFieldName,
        final boolean flattenedParentField)
    {
        final ParameterSpec paramSingleFieldValue = ParameterSpec
            .builder(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue), "value")
            .addModifiers(Modifier.FINAL)
            .build();

        final String subFieldName = SchemaGeneratorHelper.toFieldNameCase(propertyName);

        // Add setter variations for multi-valued field
        if (fldIsMultiValued) {
            // Set array value
            addArrayParamSetterMethod(
                objectBuilderClassBuilder,
                fieldFunctionName,
                propertyName,
                subFieldName,
                fieldTypeValue,
                isSubfield,
                parentFieldName,
                flattenedParentField);

            // Set List value
            addListParamSetterMethod(
                objectBuilderClassBuilder,
                fieldFunctionName,
                propertyName,
                subFieldName,
                fieldTypeValue,
                isSubfield,
                parentFieldName,
                flattenedParentField);

            // Add single value
            addSingleValueAddMethod(
                objectBuilderClassBuilder,
                paramSingleFieldValue,
                fieldFunctionName,
                propertyName,
                subFieldName,
                fieldTypeValue,
                isSubfield,
                parentFieldName,
                flattenedParentField);
        }

        final MethodSpec.Builder setSingleFieldValueMethodBuilder = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(paramSingleFieldValue);

        final MethodSpec.Builder clearFieldMethodBuilder = MethodSpec.methodBuilder("clear" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC);

        if (isSubfield) {
            if (flattenedParentField) {
                clearFieldMethodBuilder
                    .addStatement(
                        "schemaObjectBuilder.clearField($L.$L)",
                        SchemaGeneratorHelper.CLASS_NAME, parentFieldName + "." + propertyName);

                setSingleFieldValueMethodBuilder.addStatement(
                    "schemaObjectBuilder.set$LFieldValue($L.$L, value)",
                    PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(),
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName + "." + propertyName);
            } else {
                // Add instance variable for subField
                final FieldSpec field = FieldSpec
                    .builder(
                        fldIsMultiValued
                            ? ParameterizedTypeName.get(
                                ClassName.get(List.class), ClassName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue)))
                            : ClassName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue)),
                        subFieldName)
                    .addModifiers(new Modifier[]{Modifier.PRIVATE})
                    .build();
                objectBuilderClassBuilder.addField(field);

                // Add clear function body
                clearFieldMethodBuilder.addStatement(subFieldName + " = null");

                // write Json fields
                writeJsonFieldsInBuildFunction(
                    buildFunctionBuilder,
                    fieldTypeValue,
                    fldIsMandatory,
                    fldIsMultiValued,
                    parentFieldName,
                    propertyName,
                    subFieldName,
                    null);

                // Add setters for multi-valued subfield
                if (fldIsMultiValued) {
                    // Add set single value function body
                    setSingleFieldValueMethodBuilder.addStatement(
                        "this.$L = new $T()",
                        subFieldName,
                        ParameterizedTypeName
                            .get(ClassName.get(ArrayList.class), TypeName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue))));
                    setSingleFieldValueMethodBuilder.addStatement("this.$L.add(value)", subFieldName);
                } else {
                    setSingleFieldValueMethodBuilder.addStatement("this.$L = value", subFieldName);
                }
            }
        } else {
            // TODO: how to ensure mandatory field is set? add validate function
            clearFieldMethodBuilder
                .addStatement("schemaObjectBuilder.clearField($L.$L)", SchemaGeneratorHelper.CLASS_NAME, propertyName);

            setSingleFieldValueMethodBuilder.addStatement(
                "schemaObjectBuilder.set$LFieldValue($L.$L, value)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), SchemaGeneratorHelper.CLASS_NAME, propertyName);

        }
        // Add single value setter method
        objectBuilderClassBuilder.addMethod(setSingleFieldValueMethodBuilder.build());

        // Add clear field method
        objectBuilderClassBuilder.addMethod(clearFieldMethodBuilder.build());
    }

    private static void addFieldListObjectBuilderBuilderParamSetter(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName,
        final String listName
    )
    {
        final String msg
        = "addFieldListObjectBuilderBuilderParamSetter : " + fieldListObjectBuilderClassBuiler
            + ", " + objBuilderClassName
            + ", " + fieldName
            + ", " + listName;
        LOGGER.log(Level.INFO, msg);
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "director")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec.Builder setBuilderFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName);
        setBuilderFieldValue
                .addStatement("final $L $L = new $L()", objBuilderClassName, varName, objBuilderClassName);
        setBuilderFieldValue.addStatement("director.accept($L)", varName)
            .addStatement("$L = new ArrayList<>()", listName)
            .addStatement("$L.add($L)", listName, varName);

        fieldListObjectBuilderClassBuiler.addMethod(setBuilderFieldValue.build());
    }

    private static void addFieldListObjectBuilderBuilderParamSetter(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName
    )
    {
        final String msg
        = "addFieldListObjectBuilderBuilderParamSetter : " + fieldListObjectBuilderClassBuiler
            + ", " + objBuilderClassName
            + ", " + fieldName;
        LOGGER.log(Level.INFO, msg);
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "director")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec.Builder setBuilderFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName);

        setBuilderFieldValue
            .addStatement("this.schemaObjectBuilder.setFlattenedFieldValue(null, builder -> {\n")
            .addStatement("final $L $L = new $L(builder)", objBuilderClassName, varName, objBuilderClassName)
            .addStatement("director.accept($L)", varName)
            //.addStatement("$L.validate()", varName) // TODO: needs to be added
            .addStatement("})");

        fieldListObjectBuilderClassBuiler.addMethod(setBuilderFieldValue.build());
    }

    private static void addFieldListObjectBuilderStreamParamSetter(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName,
        final String listName
    )
    {
        final String msg
        = "addFieldListObjectBuilderStreamParamSetter : " + fieldListObjectBuilderClassBuiler
            + ", " + objBuilderClassName
            + ", " + fieldName
            + ", " + listName;
        LOGGER.log(Level.INFO, msg);
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec.Builder setStreamFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName)
            .addCode("$L = directors.map(director -> {\n", listName);
        setStreamFieldValue
            .addStatement("  final $L $L = new $L()", objBuilderClassName, varName, objBuilderClassName);

        setStreamFieldValue.addStatement("  director.accept($L)", varName)
            .addStatement("  return $L", varName)
            .addStatement("}).collect($T.toList())", Collectors.class);

        fieldListObjectBuilderClassBuiler.addMethod(setStreamFieldValue.build());
    }

    private static void addFieldListObjectBuilderStreamParamSetter(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String fieldName
    )
    {
        final String msg
        = "addFieldListObjectBuilderStreamParamSetter : " + fieldListObjectBuilderClassBuiler
            + ", " + objBuilderClassName
            + ", " + fieldName;
        LOGGER.log(Level.INFO, msg);
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();
        final String varName = fieldName + "ObjectBuilder";
        final MethodSpec.Builder setStreamFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName);

        setStreamFieldValue
        .addStatement("this.schemaObjectBuilder.setFlattenedFieldValue(null, directors.map(director -> builder -> {\n")
        .addStatement("final $L $L = new $L(builder)", objBuilderClassName, varName, objBuilderClassName)
        .addStatement("director.accept($L)", varName)
        // .addStatement("$L.validate()", varName) // TODO: needs to be added
        .addStatement("}))");

        fieldListObjectBuilderClassBuiler.addMethod(setStreamFieldValue.build());
    }

    private static void addFieldListObjectBuilderListParamSetter(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName
    )
    {
        final String msg
        = "addFieldListObjectBuilderListParamSetter : " + fieldListObjectBuilderClassBuiler
            + ", " + objBuilderClassName;
        LOGGER.log(Level.INFO, msg);
        final ParameterizedTypeName builderTypeName = ParameterizedTypeName
            .get(ClassName.get(Consumer.class), ClassName.get("", objBuilderClassName));

        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(List.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec setBuilderFieldValue = MethodSpec.methodBuilder("set")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName)
            .addStatement("set(directors.stream())")
            .build();

        fieldListObjectBuilderClassBuiler.addMethod(setBuilderFieldValue);
    }

    private static void addFieldListObjectBuilderClearFunction(
        final Builder fieldListObjectBuilderClassBuiler,
        final String listName
    )
    {
        final String msg
        = "addFieldListObjectBuilderClearFunction : " + fieldListObjectBuilderClassBuiler
            + ", " + listName;
        LOGGER.log(Level.INFO, msg);
        final MethodSpec setBuilderFieldValue = MethodSpec.methodBuilder("clear")
            .addModifiers(Modifier.PUBLIC)
            .addStatement("$L = null", listName)
            .build();

        fieldListObjectBuilderClassBuiler.addMethod(setBuilderFieldValue);
    }

    private static void addFieldListObjectBuilderClearFunction(
        final Builder fieldListObjectBuilderClassBuiler
    )
    {
        final String msg
        = "addFieldListObjectBuilderClearFunction : " + fieldListObjectBuilderClassBuiler;
        LOGGER.log(Level.INFO, msg);
        final MethodSpec setBuilderFieldValue = MethodSpec.methodBuilder("clear")
            .addModifiers(Modifier.PUBLIC)
            .addStatement("this.schemaObjectBuilder.clearField(null)")
            .build();

        fieldListObjectBuilderClassBuiler.addMethod(setBuilderFieldValue);
    }

    private static void addFieldListObjectBuilderBuildFunction(
        final Builder fieldListObjectBuilderClassBuiler,
        final String objBuilderClassName,
        final String listName
    )
    {
        final String msg
        = "addFieldListObjectBuilderBuildFunction : " + fieldListObjectBuilderClassBuiler
            + ", " + objBuilderClassName
            + ", " + listName;
        LOGGER.log(Level.INFO, msg);
        final MethodSpec buildFunctionBuilder = MethodSpec.methodBuilder("build")
            .addModifiers(Modifier.PRIVATE)
            .addParameter(ParameterSpec.builder(JsonBuilder.class, "jsonBuilder")
            .addModifiers(Modifier.FINAL).build())
            .addStatement("jsonBuilder.writeStartArray()")
            .beginControlFlow("if ($L != null)", listName)
            .beginControlFlow("for (final $L value : $L)", objBuilderClassName, listName)
            .addStatement("value.build(jsonBuilder)")
            .endControlFlow()
            .endControlFlow()
            .addStatement("jsonBuilder.writeEndArray()")
            .build();

        fieldListObjectBuilderClassBuiler.addMethod(buildFunctionBuilder);
    }

    private static void writeJsonFieldsInBuildFunction(
        final MethodSpec.Builder buildFunctionBuilder,
        final String fieldTypeValue,
        final boolean fldIsMandatory,
        final boolean fldIsMultiValued,
        final String parentFieldName,
        final String propertyName,
        final String subFieldName,
        final String objBuilderClassName)
    {
        final String msg
        = "writeJsonFields : " + buildFunctionBuilder
            + ", " + fieldTypeValue
            + ", " + fldIsMandatory
            + ", " + fldIsMultiValued
            + ", " + parentFieldName
            + ", " + propertyName
            + ", " + subFieldName
            + ", " + objBuilderClassName;
        LOGGER.log(Level.INFO, msg);
        if(fldIsMandatory) {
            buildFunctionBuilder
                .beginControlFlow("if ($L == null)", subFieldName)
                .addStatement(
                    "throw new IllegalArgumentException(\"Mandatory field '$L.$L.$L' is not set\")",
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName)
                .nextControlFlow("else");
        } else {
            buildFunctionBuilder.beginControlFlow("if ($L != null)", subFieldName);
        }
        buildFunctionBuilder.addStatement(
            "jsonBuilder.writeFieldName($L.$L.$L.getFieldName())", SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName);

        if (fldIsMultiValued) {
            // Add build function body
            buildFunctionBuilder.addStatement("jsonBuilder.writeStartArray()");

            if (objBuilderClassName == null) {
                buildFunctionBuilder.beginControlFlow(
                    "for(final $L value : $L)", PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), subFieldName);
                buildFunctionBuilder.addStatement(
                    "jsonBuilder.write$L(value)", PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName());
            } else {
                buildFunctionBuilder.beginControlFlow("for(final $L value : $L)", objBuilderClassName, subFieldName);
                buildFunctionBuilder.addStatement("value.build(jsonBuilder)");
            }
            buildFunctionBuilder.endControlFlow();

            buildFunctionBuilder.addStatement("jsonBuilder.writeEndArray()");
        } else {
            buildFunctionBuilder.addStatement(
                "jsonBuilder.write$L($L)", PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), subFieldName);
        }
        buildFunctionBuilder.endControlFlow();
    }

    private static void addBuilderParamSetterFunction(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFlattened
    )
    {
        final String msg
        = "addBuilderParamSetter : " + objectBuilderClassBuilder
            + ", " + fieldFunctionName
            + ", " + propertyName
            + ", " + builderTypeName
            + ", " + objBuilderClassName
            + ", " + internalBuilderVarName
            + ", " + isFlattened;
        LOGGER.log(Level.INFO, msg);
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "director")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setBuilderFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName);
        if (isFlattened) {
            setBuilderFieldValue
            .addCode("schemaObjectBuilder.setFlattenedFieldValue($L.$L, sBuilder-> {\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
            .addStatement("    final $L $L = new $L(sBuilder)", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("    director.accept($L)", internalBuilderVarName)
            .addStatement("})");
        } else {
            setBuilderFieldValue
            .addStatement("final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
            .addStatement("director.accept($L)", internalBuilderVarName)
            .addCode("schemaObjectBuilder.setJsonFieldValue(\n")
            .addCode("  $L.$L,\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
            .beginControlFlow("  jsonBuilder ->")
            .addStatement("  $L.build(jsonBuilder)", internalBuilderVarName)
            .endControlFlow().addStatement(")");
        }

        objectBuilderClassBuilder.addMethod(setBuilderFieldValue.build());
    }

    private static void addBuilderStreamParamSetterFunction(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFlattened
    )
    {
        final String msg
        = "addBuilderStreamParamSetter : " + objectBuilderClassBuilder
            + ", " + fieldFunctionName
            + ", " + propertyName
            + ", " + builderTypeName
            + ", " + objBuilderClassName
            + ", " + internalBuilderVarName
            + ", " + isFlattened;
        LOGGER.log(Level.INFO, msg);
        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();
        final MethodSpec.Builder setStreamFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName);

        if (isFlattened) {
            setStreamFieldValue
                .addCode("  schemaObjectBuilder.setFlattenedFieldValue($L.$L,\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
                .addCode("    directors.<Consumer<SchemaObjectBuilder>>map(director -> {\n")
                .addCode("    return sBuilder -> {\n")
                .addStatement("      final $L $L = new $L(sBuilder)", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
                .addStatement("      director.accept($L)", internalBuilderVarName)
                .addStatement("    }")
                .addStatement("}))");
        } else {
            setStreamFieldValue
                .addCode("schemaObjectBuilder.setJsonFieldValue(\n")
                .addCode("  $L.$L,\n", SchemaGeneratorHelper.CLASS_NAME, propertyName)
                .addCode("  directors.<Consumer<JsonBuilder>>map(director -> {\n")
                .addStatement("    final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName)
                .addStatement("    director.accept($L)", internalBuilderVarName)
                .addCode("    return jsonBuilder -> {\n")
                .addStatement("      $L.build(jsonBuilder)", internalBuilderVarName)
                .addStatement("    }")
                .addStatement("}))");
        }
        objectBuilderClassBuilder.addMethod(setStreamFieldValue.build());
    }

    private static void addBuilderListParamSetterFunction(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName
    )
    {
        final String msg
        = "addBuilderListParamSetter : " + objectBuilderClassBuilder
            + ", " + fieldFunctionName
            + ", " + builderTypeName
            + ", " + objBuilderClassName
            + ", " + internalBuilderVarName;
        LOGGER.log(Level.INFO, msg);
        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(List.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec setListFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName)
            .addStatement("set$L(directors.stream())", fieldFunctionName)
            .build();

        objectBuilderClassBuilder.addMethod(setListFieldValue);
    }

    private static void addNestedObjectBuilderParamSetterFunction(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String internalVarName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFlattened
    )
    {
        final String msg
        = "addNestedObjectBuilderParamSetter : " + objectBuilderClassBuilder
            + ", " + fieldFunctionName
            + ", " + internalVarName
            + ", " + builderTypeName
            + ", " + objBuilderClassName
            + ", " + internalBuilderVarName
            + ", " + isFlattened;
        LOGGER.log(Level.INFO, msg);
        final ParameterSpec builderParamName = ParameterSpec
            .builder(builderTypeName, "director")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setBuilderFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(builderParamName);
        if(isFlattened) {
            setBuilderFieldValue
                .addStatement(
                    "final $L $L = new $L(this.schemaObjectBuilder)",
                    objBuilderClassName, internalBuilderVarName, objBuilderClassName);
        } else {
            setBuilderFieldValue
                .addStatement("final $L $L = new $L()", objBuilderClassName, internalBuilderVarName, objBuilderClassName);
        }
        setBuilderFieldValue
            .addStatement("director.accept($L)", internalBuilderVarName)
            .addStatement("$L = new ArrayList<>()", internalVarName)
            .addStatement("$L.add($L)", internalVarName, internalBuilderVarName);

        objectBuilderClassBuilder.addMethod(setBuilderFieldValue.build());
    }

    private static void addNestedObjectBuilderStreamParamSetterFunction(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String internalVarName,
        final ParameterizedTypeName builderTypeName,
        final String objBuilderClassName,
        final String internalBuilderVarName,
        final boolean isFlattened
    )
    {
        final String msg
        = "addNestedObjectBuilderStreamParamSetter : " + objectBuilderClassBuilder
            + ", " + fieldFunctionName
            + ", " + internalVarName
            + ", " + builderTypeName
            + ", " + objBuilderClassName
            + ", " + internalBuilderVarName
            + ", " + isFlattened;
        LOGGER.log(Level.INFO, msg);
        final ParameterSpec streamParamFieldName = ParameterSpec
            .builder(ParameterizedTypeName.get(ClassName.get(Stream.class), builderTypeName), "directors")
            .addModifiers(Modifier.FINAL)
            .build();
        final MethodSpec.Builder setStreamFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(streamParamFieldName)
            .addCode("$L = directors.map(director -> {\n", internalVarName);
        if (isFlattened) {
            setStreamFieldValue.addStatement(
                "  final $L $L = new $L(this.schemaObjectBuilder)",
                objBuilderClassName, internalBuilderVarName, objBuilderClassName);
        } else {
            setStreamFieldValue.addStatement("  final $L $L = new $L()",
                objBuilderClassName, internalBuilderVarName, objBuilderClassName);
        }
        setStreamFieldValue
            .addStatement("  director.accept($L)", internalBuilderVarName)
            .addStatement("  return $L", internalBuilderVarName)
            .addStatement("}).collect($T.toList())", Collectors.class);

        objectBuilderClassBuilder.addMethod(setStreamFieldValue.build());
    }

    private static void addArrayParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield,
        final String parentFieldName,
        final boolean flattenedParentField
    )
    {
        final String msg
        = "addArrayParamSetter : " + objectBuilderClassBuilder
            + ", " + fieldFunctionName
            + ", " + propertyName
            + ", " + subFieldName
            + ", " + fieldTypeValue
            + ", " + isSubfield
            + ", " + parentFieldName
            + ", " + flattenedParentField;
        LOGGER.log(Level.INFO, msg);
        final ParameterSpec arrayParamFieldName = ParameterSpec
            .builder( ArrayTypeName.of(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue)), "values")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setArrayFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(arrayParamFieldName)
            .varargs(true);

        if (isSubfield) {
            if(flattenedParentField) {
                setArrayFieldValue.addStatement(
                    "schemaObjectBuilder.set$LFieldValue($L.$L.$L, values)",
                    PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(),
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName);
            } else {
                setArrayFieldValue.addStatement("this.$L = $T.asList(values)", subFieldName, Arrays.class);
            }
        } else {
            setArrayFieldValue.addStatement(
                "schemaObjectBuilder.set$LFieldValue($L.$L, values)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), SchemaGeneratorHelper.CLASS_NAME, propertyName);
        }
        objectBuilderClassBuilder.addMethod(setArrayFieldValue.build());
    }

    private static void addListParamSetterMethod(
        final Builder objectBuilderClassBuilder,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield,
        final String parentFieldName,
        final boolean flattenedParentField
    )
    {
        final String msg
        = "addListParamSetter : " + objectBuilderClassBuilder
            + ", " + fieldFunctionName
            + ", " + propertyName
            + ", " + subFieldName
            + ", " + fieldTypeValue
            + ", " + isSubfield
            + ", " + parentFieldName
            + ", " + flattenedParentField;
        LOGGER.log(Level.INFO, msg);
        final ParameterSpec listParamFieldName = ParameterSpec
            .builder(
                ParameterizedTypeName.get(ClassName.get(List.class), TypeName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue))),
                "values")
            .addModifiers(Modifier.FINAL)
            .build();

        final MethodSpec.Builder setListFieldValue = MethodSpec.methodBuilder("set" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(listParamFieldName);

        if (isSubfield) {
            if(flattenedParentField) {
                setListFieldValue.addStatement(
                    "schemaObjectBuilder.set$LFieldValue($L.$L.$L, values)",
                    PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(),
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName);
            } else {
                setListFieldValue.addStatement("this.$L = values", subFieldName);
            }
        } else {
            setListFieldValue.addStatement(
                "schemaObjectBuilder.set$LFieldValue($L.$L, values)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), SchemaGeneratorHelper.CLASS_NAME, propertyName);
        }

        objectBuilderClassBuilder.addMethod(setListFieldValue.build());
    }

    private static void addSingleValueAddMethod(
        final Builder objectBuilderClassBuilder,
        final ParameterSpec paramSingleFieldValue,
        final String fieldFunctionName,
        final String propertyName,
        final String subFieldName,
        final String fieldTypeValue,
        final boolean isSubfield,
        final String parentFieldName,
        final boolean flattenedParentField
    )
    {
        final String msg
        = "addSingleValueAddFunction : " + objectBuilderClassBuilder
            + ", " + paramSingleFieldValue
            + ", " + fieldFunctionName
            + ", " + propertyName
            + ", " + subFieldName
            + ", " + fieldTypeValue
            + ", " + isSubfield
            + ", " + parentFieldName
            + ", " + flattenedParentField;
        LOGGER.log(Level.INFO, msg);
        final MethodSpec.Builder addFieldValue = MethodSpec.methodBuilder("add" + fieldFunctionName)
            .addModifiers(Modifier.PUBLIC)
            .addParameter(paramSingleFieldValue);

        if (isSubfield) {
            if(flattenedParentField) {
                addFieldValue.addStatement(
                    "schemaObjectBuilder.add$LFieldValue($L.$L.$L, value)",
                    PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(),
                    SchemaGeneratorHelper.CLASS_NAME, parentFieldName, propertyName);
            } else {
                addFieldValue.beginControlFlow("if ($L == null)", subFieldName);
                addFieldValue.addStatement(
                    "this.$L = new $T()",
                    subFieldName,
                    ParameterizedTypeName.get(ClassName.get(ArrayList.class), TypeName.get(PROPERTY_TYPES_LOOKUP.get(fieldTypeValue))));
                addFieldValue.endControlFlow();
                addFieldValue.addStatement("this.$L.add(value)", subFieldName);
            }
        } else {
            addFieldValue.addStatement(
                "schemaObjectBuilder.add$LFieldValue($L.$L, value)",
                PROPERTY_TYPES_LOOKUP.get(fieldTypeValue).getSimpleName(), SchemaGeneratorHelper.CLASS_NAME, propertyName);
        }

        objectBuilderClassBuilder.addMethod(addFieldValue.build());
    }

}
